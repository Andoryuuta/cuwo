# Copyright (c) Mathias Kaerlev 2013-2014.
#
# This file is part of cuwo.
#
# cuwo is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cuwo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cuwo.  If not, see <http://www.gnu.org/licenses/>.

"""
tgen wrap

NOTE: This file is automatically generated. Do not modify.
"""

cimport numpy as np
import numpy as np
from cython cimport view
from libc.string cimport memset, memcpy
from cuwo.vector import Vector3
from cuwo.common import filter_bytes
from cuwo import strings
from cuwo.bytes cimport ByteReader, ByteWriter
from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free


cdef class WrapItemUpgrade:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemUpgrade))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemUpgrade))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapItemUpgrade c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapItemUpgrade inst = WrapItemUpgrade.__new__(WrapItemUpgrade)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemUpgrade))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(ItemUpgrade))
        self.data = <ItemUpgrade*>self.storage
    @property
    def x(self):
        return <int8_t>(<int8_t>self.data[0].x)
    @x.setter
    def x(self, value):
        self.data[0].x = value
    @property
    def y(self):
        return <int8_t>(<int8_t>self.data[0].y)
    @y.setter
    def y(self, value):
        self.data[0].y = value
    @property
    def z(self):
        return <int8_t>(<int8_t>self.data[0].z)
    @z.setter
    def z(self, value):
        self.data[0].z = value
    @property
    def material(self):
        return <int8_t>(<int8_t>self.data[0].material)
    @material.setter
    def material(self, value):
        self.data[0].material = value
    @property
    def level(self):
        return <int32_t>(<int32_t>self.data[0].level)
    @level.setter
    def level(self, value):
        self.data[0].level = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapItemData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemData))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapItemData c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapItemData inst = WrapItemData.__new__(WrapItemData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemData))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(ItemData))
        self.data = <ItemData*>self.storage
    @property
    def type(self):
        return <uint8_t>(<uint8_t>self.data[0].type)
    @type.setter
    def type(self, value):
        self.data[0].type = value
    @property
    def sub_type(self):
        return <uint8_t>(<uint8_t>self.data[0].sub_type)
    @sub_type.setter
    def sub_type(self, value):
        self.data[0].sub_type = value
    @property
    def modifier(self):
        return <uint32_t>(<uint32_t>self.data[0].modifier)
    @modifier.setter
    def modifier(self, value):
        self.data[0].modifier = value
    @property
    def minus_modifier(self):
        return <uint32_t>(<uint32_t>self.data[0].minus_modifier)
    @minus_modifier.setter
    def minus_modifier(self, value):
        self.data[0].minus_modifier = value
    @property
    def rarity(self):
        return <uint8_t>(<uint8_t>self.data[0].rarity)
    @rarity.setter
    def rarity(self, value):
        self.data[0].rarity = value
    @property
    def material(self):
        return <uint8_t>(<uint8_t>self.data[0].material)
    @material.setter
    def material(self, value):
        self.data[0].material = value
    @property
    def flags(self):
        return <uint8_t>(<uint8_t>self.data[0].flags)
    @flags.setter
    def flags(self, value):
        self.data[0].flags = value
    @property
    def level(self):
        return <int16_t>(<int16_t>self.data[0].level)
    @level.setter
    def level(self, value):
        self.data[0].level = value
    @property
    def items(self):
        cdef WrapArray0 ret = WrapArray0.__new__(WrapArray0)
        ret.array = &self.data[0].items[0]
        return ret
    @items.setter
    def items(self, value):
        raise NotImplementedError()
    @property
    def upgrade_count(self):
        return <uint32_t>(<uint32_t>self.data[0].upgrade_count)
    @upgrade_count.setter
    def upgrade_count(self, value):
        self.data[0].upgrade_count = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
        self.data[0].level = 1
cdef class WrapAppearanceData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(AppearanceData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(AppearanceData))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapAppearanceData c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapAppearanceData inst = WrapAppearanceData.__new__(WrapAppearanceData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(AppearanceData))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(AppearanceData))
        self.data = <AppearanceData*>self.storage
    @property
    def not_used_1(self):
        return <uint8_t>(<uint8_t>self.data[0].not_used_1)
    @not_used_1.setter
    def not_used_1(self, value):
        self.data[0].not_used_1 = value
    @property
    def not_used_2(self):
        return <uint8_t>(<uint8_t>self.data[0].not_used_2)
    @not_used_2.setter
    def not_used_2(self, value):
        self.data[0].not_used_2 = value
    @property
    def hair_red(self):
        return <uint8_t>(<uint8_t>self.data[0].hair_red)
    @hair_red.setter
    def hair_red(self, value):
        self.data[0].hair_red = value
    @property
    def hair_green(self):
        return <uint8_t>(<uint8_t>self.data[0].hair_green)
    @hair_green.setter
    def hair_green(self, value):
        self.data[0].hair_green = value
    @property
    def hair_blue(self):
        return <uint8_t>(<uint8_t>self.data[0].hair_blue)
    @hair_blue.setter
    def hair_blue(self, value):
        self.data[0].hair_blue = value
    @property
    def flags(self):
        return <uint16_t>(<uint16_t>self.data[0].flags)
    @flags.setter
    def flags(self, value):
        self.data[0].flags = value
    @property
    def scale(self):
        cdef float * ptr = &self.data[0].scale[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @scale.setter
    def scale(self, value):
        self.data[0].scale = value
    @property
    def head_model(self):
        return <int16_t>(<int16_t>self.data[0].head_model)
    @head_model.setter
    def head_model(self, value):
        self.data[0].head_model = value
    @property
    def hair_model(self):
        return <int16_t>(<int16_t>self.data[0].hair_model)
    @hair_model.setter
    def hair_model(self, value):
        self.data[0].hair_model = value
    @property
    def hand_model(self):
        return <int16_t>(<int16_t>self.data[0].hand_model)
    @hand_model.setter
    def hand_model(self, value):
        self.data[0].hand_model = value
    @property
    def foot_model(self):
        return <int16_t>(<int16_t>self.data[0].foot_model)
    @foot_model.setter
    def foot_model(self, value):
        self.data[0].foot_model = value
    @property
    def body_model(self):
        return <int16_t>(<int16_t>self.data[0].body_model)
    @body_model.setter
    def body_model(self, value):
        self.data[0].body_model = value
    @property
    def tail_model(self):
        return <int16_t>(<int16_t>self.data[0].tail_model)
    @tail_model.setter
    def tail_model(self, value):
        self.data[0].tail_model = value
    @property
    def shoulder2_model(self):
        return <int16_t>(<int16_t>self.data[0].shoulder2_model)
    @shoulder2_model.setter
    def shoulder2_model(self, value):
        self.data[0].shoulder2_model = value
    @property
    def wing_model(self):
        return <int16_t>(<int16_t>self.data[0].wing_model)
    @wing_model.setter
    def wing_model(self, value):
        self.data[0].wing_model = value
    @property
    def head_scale(self):
        return <float>(<float>self.data[0].head_scale)
    @head_scale.setter
    def head_scale(self, value):
        self.data[0].head_scale = value
    @property
    def body_scale(self):
        return <float>(<float>self.data[0].body_scale)
    @body_scale.setter
    def body_scale(self, value):
        self.data[0].body_scale = value
    @property
    def hand_scale(self):
        return <float>(<float>self.data[0].hand_scale)
    @hand_scale.setter
    def hand_scale(self, value):
        self.data[0].hand_scale = value
    @property
    def foot_scale(self):
        return <float>(<float>self.data[0].foot_scale)
    @foot_scale.setter
    def foot_scale(self, value):
        self.data[0].foot_scale = value
    @property
    def shoulder2_scale(self):
        return <float>(<float>self.data[0].shoulder2_scale)
    @shoulder2_scale.setter
    def shoulder2_scale(self, value):
        self.data[0].shoulder2_scale = value
    @property
    def weapon_scale(self):
        return <float>(<float>self.data[0].weapon_scale)
    @weapon_scale.setter
    def weapon_scale(self, value):
        self.data[0].weapon_scale = value
    @property
    def tail_scale(self):
        return <float>(<float>self.data[0].tail_scale)
    @tail_scale.setter
    def tail_scale(self, value):
        self.data[0].tail_scale = value
    @property
    def shoulder_scale(self):
        return <float>(<float>self.data[0].shoulder_scale)
    @shoulder_scale.setter
    def shoulder_scale(self, value):
        self.data[0].shoulder_scale = value
    @property
    def wing_scale(self):
        return <float>(<float>self.data[0].wing_scale)
    @wing_scale.setter
    def wing_scale(self, value):
        self.data[0].wing_scale = value
    @property
    def body_pitch(self):
        return <float>(<float>self.data[0].body_pitch)
    @body_pitch.setter
    def body_pitch(self, value):
        self.data[0].body_pitch = value
    @property
    def arm_pitch(self):
        return <float>(<float>self.data[0].arm_pitch)
    @arm_pitch.setter
    def arm_pitch(self, value):
        self.data[0].arm_pitch = value
    @property
    def arm_roll(self):
        return <float>(<float>self.data[0].arm_roll)
    @arm_roll.setter
    def arm_roll(self, value):
        self.data[0].arm_roll = value
    @property
    def arm_yaw(self):
        return <float>(<float>self.data[0].arm_yaw)
    @arm_yaw.setter
    def arm_yaw(self, value):
        self.data[0].arm_yaw = value
    @property
    def feet_pitch(self):
        return <float>(<float>self.data[0].feet_pitch)
    @feet_pitch.setter
    def feet_pitch(self, value):
        self.data[0].feet_pitch = value
    @property
    def wing_pitch(self):
        return <float>(<float>self.data[0].wing_pitch)
    @wing_pitch.setter
    def wing_pitch(self, value):
        self.data[0].wing_pitch = value
    @property
    def back_pitch(self):
        return <float>(<float>self.data[0].back_pitch)
    @back_pitch.setter
    def back_pitch(self, value):
        self.data[0].back_pitch = value
    @property
    def body_offset(self):
        cdef float * ptr = &self.data[0].body_offset[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @body_offset.setter
    def body_offset(self, value):
        self.data[0].body_offset = value
    @property
    def head_offset(self):
        cdef float * ptr = &self.data[0].head_offset[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @head_offset.setter
    def head_offset(self, value):
        self.data[0].head_offset = value
    @property
    def hand_offset(self):
        cdef float * ptr = &self.data[0].hand_offset[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @hand_offset.setter
    def hand_offset(self, value):
        self.data[0].hand_offset = value
    @property
    def foot_offset(self):
        cdef float * ptr = &self.data[0].foot_offset[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @foot_offset.setter
    def foot_offset(self, value):
        self.data[0].foot_offset = value
    @property
    def tail_offset(self):
        cdef float * ptr = &self.data[0].tail_offset[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @tail_offset.setter
    def tail_offset(self, value):
        self.data[0].tail_offset = value
    @property
    def wing_offset(self):
        cdef float * ptr = &self.data[0].wing_offset[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @wing_offset.setter
    def wing_offset(self, value):
        self.data[0].wing_offset = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
        self.data[0].hair_red = 255
        self.data[0].hair_green = 255
        self.data[0].hair_blue = 255
        self.data[0].head_model = -1
        self.data[0].hair_model = -1
        self.data[0].hand_model = -1
        self.data[0].foot_model = -1
        self.data[0].body_model = -1
        self.data[0].tail_model = -1
        self.data[0].shoulder2_model = -1
        self.data[0].wing_model = -1

    def get_head(self):
        return strings.MODEL_NAMES[self.data[0].head_model]

    def set_head(self, name):
        self.data[0].head_model = strings.MODEL_IDS[name]

    def get_hair(self):
        return strings.MODEL_NAMES[self.data[0].hair_model]

    def set_hair(self, name):
        self.data[0].hair_model = strings.MODEL_IDS[name]

    def get_hand(self):
        return strings.MODEL_NAMES[self.data[0].hand_model]

    def set_hand(self, name):
        self.data[0].hand_model = strings.MODEL_IDS[name]

    def get_foot(self):
        return strings.MODEL_NAMES[self.data[0].foot_model]

    def set_foot(self, name):
        self.data[0].foot_model = strings.MODEL_IDS[name]

    def get_body(self):
        return strings.MODEL_NAMES[self.data[0].body_model]

    def set_body(self, name):
        self.data[0].body_model = strings.MODEL_IDS[name]

    def get_tail(self):
        return strings.MODEL_NAMES[self.data[0].tail_model]

    def set_tail(self, name):
        self.data[0].tail_model = strings.MODEL_IDS[name]

    def get_shoulder2(self):
        return strings.MODEL_NAMES[self.data[0].shoulder2_model]

    def set_shoulder2(self, name):
        self.data[0].shoulder2_model = strings.MODEL_IDS[name]

    def get_wing(self):
        return strings.MODEL_NAMES[self.data[0].wing_model]

    def set_wing(self, name):
        self.data[0].wing_model = strings.MODEL_IDS[name]
POS_BIT = 0
POS_FLAG = 0x1
ORIENT_BIT = 1
ORIENT_FLAG = 0x2
VEL_BIT = 2
VEL_FLAG = 0x4
ACCEL_BIT = 3
ACCEL_FLAG = 0x8
EXTRA_VEL_BIT = 4
EXTRA_VEL_FLAG = 0x10
LOOK_PITCH_BIT = 5
LOOK_PITCH_FLAG = 0x20
PHYSICS_BIT = 6
PHYSICS_FLAG = 0x40
HOSTILE_BIT = 7
HOSTILE_FLAG = 0x80
TYPE_BIT = 8
TYPE_FLAG = 0x100
MODE_BIT = 9
MODE_FLAG = 0x200
MODE_TIME_BIT = 10
MODE_TIME_FLAG = 0x400
HIT_COUNTER_BIT = 11
HIT_COUNTER_FLAG = 0x800
LAST_HIT_BIT = 12
LAST_HIT_FLAG = 0x1000
APPEARANCE_BIT = 13
APPEARANCE_FLAG = 0x2000
FLAGS_BIT = 14
FLAGS_FLAG = 0x4000
ROLL_BIT = 15
ROLL_FLAG = 0x8000
STUN_BIT = 16
STUN_FLAG = 0x10000
SLOWED_BIT = 17
SLOWED_FLAG = 0x20000
MAKE_BLUE_BIT = 18
MAKE_BLUE_FLAG = 0x40000
SPEED_UP_BIT = 19
SPEED_UP_FLAG = 0x80000
SHOW_PATCH_BIT = 20
SHOW_PATCH_FLAG = 0x100000
CLASS_BIT = 21
CLASS_FLAG = 0x200000
SPECIALIZATION_BIT = 22
SPECIALIZATION_FLAG = 0x400000
CHARGED_MP_BIT = 23
CHARGED_MP_FLAG = 0x800000
RAY_BIT = 26
RAY_FLAG = 0x4000000
HP_BIT = 27
HP_FLAG = 0x8000000
MP_BIT = 28
MP_FLAG = 0x10000000
BLOCK_POWER_BIT = 29
BLOCK_POWER_FLAG = 0x20000000
MULTIPLIER_BIT = 30
MULTIPLIER_FLAG = 0x40000000
LEVEL_BIT = 33
LEVEL_FLAG = 0x200000000
XP_BIT = 34
XP_FLAG = 0x400000000
OWNER_BIT = 35
OWNER_FLAG = 0x800000000
POWER_BASE_BIT = 37
POWER_BASE_FLAG = 0x2000000000
START_CHUNK_BIT = 39
START_CHUNK_FLAG = 0x8000000000
SPAWN_BIT = 40
SPAWN_FLAG = 0x10000000000
CONSUMABLE_BIT = 43
CONSUMABLE_FLAG = 0x80000000000
EQUIPMENT_BIT = 44
EQUIPMENT_FLAG = 0x100000000000
NAME_BIT = 45
NAME_FLAG = 0x200000000000
SKILL_BIT = 46
SKILL_FLAG = 0x400000000000
MANA_CUBES_BIT = 47
MANA_CUBES_FLAG = 0x800000000000


cdef class WrapEntityData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(EntityData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(EntityData))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapEntityData c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapEntityData inst = WrapEntityData.__new__(WrapEntityData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(EntityData))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(EntityData))
        self.data = <EntityData*>self.storage
    @property
    def pos(self):
        cdef int64_t * ptr = &self.data[0].pos[0]
        return np.asarray(<int64_t[:3]>ptr).view(Vector3)
    @pos.setter
    def pos(self, value):
        self.data[0].pos = value
    @property
    def body_roll(self):
        return <float>(<float>self.data[0].body_roll)
    @body_roll.setter
    def body_roll(self, value):
        self.data[0].body_roll = value
    @property
    def body_pitch(self):
        return <float>(<float>self.data[0].body_pitch)
    @body_pitch.setter
    def body_pitch(self, value):
        self.data[0].body_pitch = value
    @property
    def body_yaw(self):
        return <float>(<float>self.data[0].body_yaw)
    @body_yaw.setter
    def body_yaw(self, value):
        self.data[0].body_yaw = value
    @property
    def velocity(self):
        cdef float * ptr = &self.data[0].velocity[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @velocity.setter
    def velocity(self, value):
        self.data[0].velocity = value
    @property
    def accel(self):
        cdef float * ptr = &self.data[0].accel[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @accel.setter
    def accel(self, value):
        self.data[0].accel = value
    @property
    def extra_vel(self):
        cdef float * ptr = &self.data[0].extra_vel[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @extra_vel.setter
    def extra_vel(self, value):
        self.data[0].extra_vel = value
    @property
    def look_pitch(self):
        return <float>(<float>self.data[0].look_pitch)
    @look_pitch.setter
    def look_pitch(self, value):
        self.data[0].look_pitch = value
    @property
    def physics_flags(self):
        return <uint32_t>(<uint32_t>self.data[0].physics_flags)
    @physics_flags.setter
    def physics_flags(self, value):
        self.data[0].physics_flags = value
    @property
    def hostile_type(self):
        return <uint8_t>(<uint8_t>self.data[0].hostile_type)
    @hostile_type.setter
    def hostile_type(self, value):
        self.data[0].hostile_type = value
    @property
    def entity_type(self):
        return <uint32_t>(<uint32_t>self.data[0].entity_type)
    @entity_type.setter
    def entity_type(self, value):
        self.data[0].entity_type = value
    @property
    def current_mode(self):
        return <uint8_t>(<uint8_t>self.data[0].current_mode)
    @current_mode.setter
    def current_mode(self, value):
        self.data[0].current_mode = value
    @property
    def mode_start_time(self):
        return <uint32_t>(<uint32_t>self.data[0].mode_start_time)
    @mode_start_time.setter
    def mode_start_time(self, value):
        self.data[0].mode_start_time = value
    @property
    def hit_counter(self):
        return <uint32_t>(<uint32_t>self.data[0].hit_counter)
    @hit_counter.setter
    def hit_counter(self, value):
        self.data[0].hit_counter = value
    @property
    def last_hit_time(self):
        return <uint32_t>(<uint32_t>self.data[0].last_hit_time)
    @last_hit_time.setter
    def last_hit_time(self, value):
        self.data[0].last_hit_time = value
    @property
    def appearance(self):
        cdef WrapAppearanceData ret = WrapAppearanceData.__new__(WrapAppearanceData)
        ret.data = &self.data[0].appearance
        return ret
    @appearance.setter
    def appearance(self, value):
        cdef WrapAppearanceData v = value
        self.data[0].appearance = v.data[0]
    @property
    def flags(self):
        return <uint16_t>(<uint16_t>self.data[0].flags)
    @flags.setter
    def flags(self, value):
        self.data[0].flags = value
    @property
    def roll_time(self):
        return <uint32_t>(<uint32_t>self.data[0].roll_time)
    @roll_time.setter
    def roll_time(self, value):
        self.data[0].roll_time = value
    @property
    def stun_time(self):
        return <int32_t>(<int32_t>self.data[0].stun_time)
    @stun_time.setter
    def stun_time(self, value):
        self.data[0].stun_time = value
    @property
    def slowed_time(self):
        return <uint32_t>(<uint32_t>self.data[0].slowed_time)
    @slowed_time.setter
    def slowed_time(self, value):
        self.data[0].slowed_time = value
    @property
    def make_blue_time(self):
        return <uint32_t>(<uint32_t>self.data[0].make_blue_time)
    @make_blue_time.setter
    def make_blue_time(self, value):
        self.data[0].make_blue_time = value
    @property
    def speed_up_time(self):
        return <uint32_t>(<uint32_t>self.data[0].speed_up_time)
    @speed_up_time.setter
    def speed_up_time(self, value):
        self.data[0].speed_up_time = value
    @property
    def show_patch_time(self):
        return <float>(<float>self.data[0].show_patch_time)
    @show_patch_time.setter
    def show_patch_time(self, value):
        self.data[0].show_patch_time = value
    @property
    def class_type(self):
        return <uint8_t>(<uint8_t>self.data[0].class_type)
    @class_type.setter
    def class_type(self, value):
        self.data[0].class_type = value
    @property
    def specialization(self):
        return <uint8_t>(<uint8_t>self.data[0].specialization)
    @specialization.setter
    def specialization(self, value):
        self.data[0].specialization = value
    @property
    def charged_mp(self):
        return <float>(<float>self.data[0].charged_mp)
    @charged_mp.setter
    def charged_mp(self, value):
        self.data[0].charged_mp = value
    @property
    def not_used_1(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used_1)
    @not_used_1.setter
    def not_used_1(self, value):
        self.data[0].not_used_1 = value
    @property
    def not_used_2(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used_2)
    @not_used_2.setter
    def not_used_2(self, value):
        self.data[0].not_used_2 = value
    @property
    def not_used_3(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used_3)
    @not_used_3.setter
    def not_used_3(self, value):
        self.data[0].not_used_3 = value
    @property
    def not_used_4(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used_4)
    @not_used_4.setter
    def not_used_4(self, value):
        self.data[0].not_used_4 = value
    @property
    def not_used_5(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used_5)
    @not_used_5.setter
    def not_used_5(self, value):
        self.data[0].not_used_5 = value
    @property
    def not_used_6(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used_6)
    @not_used_6.setter
    def not_used_6(self, value):
        self.data[0].not_used_6 = value
    @property
    def ray_hit(self):
        cdef float * ptr = &self.data[0].ray_hit[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @ray_hit.setter
    def ray_hit(self, value):
        self.data[0].ray_hit = value
    @property
    def hp(self):
        return <float>(<float>self.data[0].hp)
    @hp.setter
    def hp(self, value):
        self.data[0].hp = value
    @property
    def mp(self):
        return <float>(<float>self.data[0].mp)
    @mp.setter
    def mp(self, value):
        self.data[0].mp = value
    @property
    def block_power(self):
        return <float>(<float>self.data[0].block_power)
    @block_power.setter
    def block_power(self, value):
        self.data[0].block_power = value
    @property
    def max_hp_multiplier(self):
        return <float>(<float>self.data[0].max_hp_multiplier)
    @max_hp_multiplier.setter
    def max_hp_multiplier(self, value):
        self.data[0].max_hp_multiplier = value
    @property
    def shoot_speed(self):
        return <float>(<float>self.data[0].shoot_speed)
    @shoot_speed.setter
    def shoot_speed(self, value):
        self.data[0].shoot_speed = value
    @property
    def damage_multiplier(self):
        return <float>(<float>self.data[0].damage_multiplier)
    @damage_multiplier.setter
    def damage_multiplier(self, value):
        self.data[0].damage_multiplier = value
    @property
    def armor_multiplier(self):
        return <float>(<float>self.data[0].armor_multiplier)
    @armor_multiplier.setter
    def armor_multiplier(self, value):
        self.data[0].armor_multiplier = value
    @property
    def resi_multiplier(self):
        return <float>(<float>self.data[0].resi_multiplier)
    @resi_multiplier.setter
    def resi_multiplier(self, value):
        self.data[0].resi_multiplier = value
    @property
    def not_used7(self):
        return <uint8_t>(<uint8_t>self.data[0].not_used7)
    @not_used7.setter
    def not_used7(self, value):
        self.data[0].not_used7 = value
    @property
    def not_used8(self):
        return <uint8_t>(<uint8_t>self.data[0].not_used8)
    @not_used8.setter
    def not_used8(self, value):
        self.data[0].not_used8 = value
    @property
    def level(self):
        return <int32_t>(<int32_t>self.data[0].level)
    @level.setter
    def level(self, value):
        self.data[0].level = value
    @property
    def current_xp(self):
        return <int32_t>(<int32_t>self.data[0].current_xp)
    @current_xp.setter
    def current_xp(self, value):
        self.data[0].current_xp = value
    @property
    def parent_owner(self):
        return <uint64_t>(<uint64_t>self.data[0].parent_owner)
    @parent_owner.setter
    def parent_owner(self, value):
        self.data[0].parent_owner = value
    @property
    def unknown_or_not_used1(self):
        return <uint32_t>(<uint32_t>self.data[0].unknown_or_not_used1)
    @unknown_or_not_used1.setter
    def unknown_or_not_used1(self, value):
        self.data[0].unknown_or_not_used1 = value
    @property
    def unknown_or_not_used2(self):
        return <uint32_t>(<uint32_t>self.data[0].unknown_or_not_used2)
    @unknown_or_not_used2.setter
    def unknown_or_not_used2(self, value):
        self.data[0].unknown_or_not_used2 = value
    @property
    def power_base(self):
        return <uint8_t>(<uint8_t>self.data[0].power_base)
    @power_base.setter
    def power_base(self, value):
        self.data[0].power_base = value
    @property
    def unknown_or_not_used4(self):
        return <int32_t>(<int32_t>self.data[0].unknown_or_not_used4)
    @unknown_or_not_used4.setter
    def unknown_or_not_used4(self, value):
        self.data[0].unknown_or_not_used4 = value
    @property
    def start_chunk(self):
        cdef int32_t * ptr = &self.data[0].start_chunk[0]
        return np.asarray(<int32_t[:3]>ptr).view(Vector3)
    @start_chunk.setter
    def start_chunk(self, value):
        self.data[0].start_chunk = value
    @property
    def super_weird(self):
        return <uint32_t>(<uint32_t>self.data[0].super_weird)
    @super_weird.setter
    def super_weird(self, value):
        self.data[0].super_weird = value
    @property
    def spawn_pos(self):
        cdef int64_t * ptr = &self.data[0].spawn_pos[0]
        return np.asarray(<int64_t[:3]>ptr).view(Vector3)
    @spawn_pos.setter
    def spawn_pos(self, value):
        self.data[0].spawn_pos = value
    @property
    def not_used19(self):
        return <uint8_t>(<uint8_t>self.data[0].not_used19)
    @not_used19.setter
    def not_used19(self, value):
        self.data[0].not_used19 = value
    @property
    def not_used20(self):
        cdef int32_t * ptr = &self.data[0].not_used20[0]
        return np.asarray(<int32_t[:3]>ptr).view(Vector3)
    @not_used20.setter
    def not_used20(self, value):
        self.data[0].not_used20 = value
    @property
    def consumable(self):
        cdef WrapItemData ret = WrapItemData.__new__(WrapItemData)
        ret.data = &self.data[0].consumable
        return ret
    @consumable.setter
    def consumable(self, value):
        cdef WrapItemData v = value
        self.data[0].consumable = v.data[0]
    @property
    def equipment(self):
        cdef WrapArray1 ret = WrapArray1.__new__(WrapArray1)
        ret.array = &self.data[0].equipment[0]
        return ret
    @equipment.setter
    def equipment(self, value):
        raise NotImplementedError()
    @property
    def skills(self):
        return <uint32_t[:11]>(<uint32_t*>self.data[0].skills)
    @skills.setter
    def skills(self, value):
        raise NotImplementedError()
    @property
    def mana_cubes(self):
        return <uint32_t>(<uint32_t>self.data[0].mana_cubes)
    @mana_cubes.setter
    def mana_cubes(self, value):
        self.data[0].mana_cubes = value
    @property
    def name(self):
        cdef int i = 0
        while i < 16:
            if self.data[0].name[i] == 0: break
            i += 1
        return filter_bytes(self.data[0].name[:i])
    @name.setter
    def name(self, value):
        cdef str v = value
        cdef bytes vv = v.encode('ascii', 'ignore')[:16]
        self.data[0].name = vv
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
        self.data[0].hostile_type = 3
        self.data[0].stun_time = -3000
        self.data[0].hp = 500
        self.data[0].max_hp_multiplier = 100
        self.data[0].damage_multiplier = 1
        self.data[0].armor_multiplier = 1
        self.data[0].resi_multiplier = 1
        self.data[0].unknown_or_not_used4 = -1
        self.data[0].start_chunk = (-1, -1, 0)
        self.data[0].not_used20 = (-1, -1, 0)
cdef class WrapItemWithHeader:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithHeader))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithHeader))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapItemWithHeader c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapItemWithHeader inst = WrapItemWithHeader.__new__(WrapItemWithHeader)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithHeader))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(ItemWithHeader))
        self.data = <ItemWithHeader*>self.storage
    @property
    def header(self):
        return <uint32_t>(<uint32_t>self.data[0].header)
    @header.setter
    def header(self, value):
        self.data[0].header = value
    @property
    def data(self):
        cdef WrapItemData ret = WrapItemData.__new__(WrapItemData)
        ret.data = &self.data[0].data
        return ret
    @data.setter
    def data(self, value):
        cdef WrapItemData v = value
        self.data[0].data = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapItemWithHeaderList:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithHeaderList))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithHeaderList))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapItemWithHeaderList c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapItemWithHeaderList inst = WrapItemWithHeaderList.__new__(WrapItemWithHeaderList)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithHeaderList))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(ItemWithHeaderList))
        self.data = <ItemWithHeaderList*>self.storage
    @property
    def vec(self):
        cdef WrapItemWithHeaderVec ret = WrapItemWithHeaderVec.__new__(WrapItemWithHeaderVec)
        ret.data = &self.data[0].vec_start
        return ret
    @vec.setter
    def vec(self, value):
        raise NotImplementedError()
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapItemWithHeaderLists:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithHeaderLists))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithHeaderLists))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapItemWithHeaderLists c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapItemWithHeaderLists inst = WrapItemWithHeaderLists.__new__(WrapItemWithHeaderLists)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithHeaderLists))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(ItemWithHeaderLists))
        self.data = <ItemWithHeaderLists*>self.storage
    @property
    def vec(self):
        cdef WrapItemWithHeaderListVec ret = WrapItemWithHeaderListVec.__new__(WrapItemWithHeaderListVec)
        ret.data = &self.data[0].vec_start
        return ret
    @vec.setter
    def vec(self, value):
        raise NotImplementedError()
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapStaticEntityHeader:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(StaticEntityHeader))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(StaticEntityHeader))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapStaticEntityHeader c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapStaticEntityHeader inst = WrapStaticEntityHeader.__new__(WrapStaticEntityHeader)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(StaticEntityHeader))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(StaticEntityHeader))
        self.data = <StaticEntityHeader*>self.storage
    @property
    def entity_type(self):
        return <uint32_t>(<uint32_t>self.data[0].entity_type)
    @entity_type.setter
    def entity_type(self, value):
        self.data[0].entity_type = value
    @property
    def pos(self):
        cdef int64_t * ptr = &self.data[0].pos[0]
        return np.asarray(<int64_t[:3]>ptr).view(Vector3)
    @pos.setter
    def pos(self, value):
        self.data[0].pos = value
    @property
    def orientation(self):
        return <uint32_t>(<uint32_t>self.data[0].orientation)
    @orientation.setter
    def orientation(self, value):
        self.data[0].orientation = value
    @property
    def size(self):
        cdef float * ptr = &self.data[0].size[0]
        return np.asarray(<float[:3]>ptr).view(Vector3)
    @size.setter
    def size(self, value):
        self.data[0].size = value
    @property
    def closed(self):
        return <uint8_t>(<uint8_t>self.data[0].closed)
    @closed.setter
    def closed(self, value):
        self.data[0].closed = value
    @property
    def time_offset(self):
        return <uint32_t>(<uint32_t>self.data[0].time_offset)
    @time_offset.setter
    def time_offset(self, value):
        self.data[0].time_offset = value
    @property
    def something8(self):
        return <uint32_t>(<uint32_t>self.data[0].something8)
    @something8.setter
    def something8(self, value):
        self.data[0].something8 = value
    @property
    def user_id(self):
        return <uint64_t>(<uint64_t>self.data[0].user_id)
    @user_id.setter
    def user_id(self, value):
        self.data[0].user_id = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapStaticEntity:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(StaticEntity))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(StaticEntity))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapStaticEntity c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapStaticEntity inst = WrapStaticEntity.__new__(WrapStaticEntity)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(StaticEntity))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(StaticEntity))
        self.data = <StaticEntity*>self.storage
    @property
    def header(self):
        cdef WrapStaticEntityHeader ret = WrapStaticEntityHeader.__new__(WrapStaticEntityHeader)
        ret.data = &self.data[0].header
        return ret
    @header.setter
    def header(self, value):
        cdef WrapStaticEntityHeader v = value
        self.data[0].header = v.data[0]
    @property
    def item_with_header_lists(self):
        cdef WrapItemWithHeaderLists ret = WrapItemWithHeaderLists.__new__(WrapItemWithHeaderLists)
        ret.data = &self.data[0].item_with_header_lists
        return ret
    @item_with_header_lists.setter
    def item_with_header_lists(self, value):
        cdef WrapItemWithHeaderLists v = value
        self.data[0].item_with_header_lists = v.data[0]
    @property
    def something1(self):
        return <uint32_t>(<uint32_t>self.data[0].something1)
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def item(self):
        cdef WrapItemData ret = WrapItemData.__new__(WrapItemData)
        ret.data = &self.data[0].item
        return ret
    @item.setter
    def item(self, value):
        cdef WrapItemData v = value
        self.data[0].item = v.data[0]
    @property
    def something2(self):
        return <uint32_t>(<uint32_t>self.data[0].something2)
    @something2.setter
    def something2(self, value):
        self.data[0].something2 = value
    @property
    def something3(self):
        return <uint32_t>(<uint32_t>self.data[0].something3)
    @something3.setter
    def something3(self, value):
        self.data[0].something3 = value
    @property
    def something4(self):
        return <uint32_t>(<uint32_t>self.data[0].something4)
    @something4.setter
    def something4(self, value):
        self.data[0].something4 = value
    @property
    def something5(self):
        return <uint32_t>(<uint32_t>self.data[0].something5)
    @something5.setter
    def something5(self, value):
        self.data[0].something5 = value
    @property
    def something6(self):
        return <uint32_t>(<uint32_t>self.data[0].something6)
    @something6.setter
    def something6(self, value):
        self.data[0].something6 = value
    @property
    def something7(self):
        return <uint32_t>(<uint32_t>self.data[0].something7)
    @something7.setter
    def something7(self, value):
        self.data[0].something7 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapItemWithExtra:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ItemWithExtra))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ItemWithExtra))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapItemWithExtra c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapItemWithExtra inst = WrapItemWithExtra.__new__(WrapItemWithExtra)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ItemWithExtra))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(ItemWithExtra))
        self.data = <ItemWithExtra*>self.storage
    @property
    def lists(self):
        cdef WrapItemWithHeaderLists ret = WrapItemWithHeaderLists.__new__(WrapItemWithHeaderLists)
        ret.data = &self.data[0].lists
        return ret
    @lists.setter
    def lists(self, value):
        cdef WrapItemWithHeaderLists v = value
        self.data[0].lists = v.data[0]
    @property
    def something1(self):
        return <uint32_t>(<uint32_t>self.data[0].something1)
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def item(self):
        cdef WrapItemData ret = WrapItemData.__new__(WrapItemData)
        ret.data = &self.data[0].item
        return ret
    @item.setter
    def item(self, value):
        cdef WrapItemData v = value
        self.data[0].item = v.data[0]
    @property
    def something_added1(self):
        return <uint32_t>(<uint32_t>self.data[0].something_added1)
    @something_added1.setter
    def something_added1(self, value):
        self.data[0].something_added1 = value
    @property
    def something_added2(self):
        return <uint32_t>(<uint32_t>self.data[0].something_added2)
    @something_added2.setter
    def something_added2(self, value):
        self.data[0].something_added2 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapSpawn:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Spawn))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Spawn))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapSpawn c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapSpawn inst = WrapSpawn.__new__(WrapSpawn)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Spawn))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(Spawn))
        self.data = <Spawn*>self.storage
    @property
    def vtable(self):
        return <uint32_t>(<uint32_t>self.data[0].vtable)
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def something1(self):
        return <float>(<float>self.data[0].something1)
    @something1.setter
    def something1(self, value):
        self.data[0].something1 = value
    @property
    def something2(self):
        return <int8_t[:4]>(<int8_t*>self.data[0].something2)
    @something2.setter
    def something2(self, value):
        raise NotImplementedError()
    @property
    def x(self):
        return <int64_t>(<int64_t>self.data[0].x)
    @x.setter
    def x(self, value):
        self.data[0].x = value
    @property
    def y(self):
        return <int64_t>(<int64_t>self.data[0].y)
    @y.setter
    def y(self, value):
        self.data[0].y = value
    @property
    def z(self):
        return <int64_t>(<int64_t>self.data[0].z)
    @z.setter
    def z(self, value):
        self.data[0].z = value
    @property
    def hostile_type(self):
        return <int8_t>(<int8_t>self.data[0].hostile_type)
    @hostile_type.setter
    def hostile_type(self, value):
        self.data[0].hostile_type = value
    @property
    def something3(self):
        return <int8_t[:3]>(<int8_t*>self.data[0].something3)
    @something3.setter
    def something3(self, value):
        raise NotImplementedError()
    @property
    def entity_type(self):
        return <uint32_t>(<uint32_t>self.data[0].entity_type)
    @entity_type.setter
    def entity_type(self, value):
        self.data[0].entity_type = value
    @property
    def class_type(self):
        return <int8_t>(<int8_t>self.data[0].class_type)
    @class_type.setter
    def class_type(self, value):
        self.data[0].class_type = value
    @property
    def specialization(self):
        return <int8_t>(<int8_t>self.data[0].specialization)
    @specialization.setter
    def specialization(self, value):
        self.data[0].specialization = value
    @property
    def level(self):
        return <uint32_t>(<uint32_t>self.data[0].level)
    @level.setter
    def level(self, value):
        self.data[0].level = value
    @property
    def something33(self):
        return <uint32_t>(<uint32_t>self.data[0].something33)
    @something33.setter
    def something33(self, value):
        self.data[0].something33 = value
    @property
    def something34(self):
        return <uint32_t>(<uint32_t>self.data[0].something34)
    @something34.setter
    def something34(self, value):
        self.data[0].something34 = value
    @property
    def something35(self):
        return <uint32_t>(<uint32_t>self.data[0].something35)
    @something35.setter
    def something35(self, value):
        self.data[0].something35 = value
    @property
    def something36(self):
        return <uint32_t>(<uint32_t>self.data[0].something36)
    @something36.setter
    def something36(self, value):
        self.data[0].something36 = value
    @property
    def entity_id(self):
        return <uint64_t>(<uint64_t>self.data[0].entity_id)
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def enable_flag_8_flags_1(self):
        return <int8_t>(<int8_t>self.data[0].enable_flag_8_flags_1)
    @enable_flag_8_flags_1.setter
    def enable_flag_8_flags_1(self, value):
        self.data[0].enable_flag_8_flags_1 = value
    @property
    def body_yaw(self):
        return <float>(<float>self.data[0].body_yaw)
    @body_yaw.setter
    def body_yaw(self, value):
        self.data[0].body_yaw = value
    @property
    def power_base(self):
        return <int8_t>(<int8_t>self.data[0].power_base)
    @power_base.setter
    def power_base(self, value):
        self.data[0].power_base = value
    @property
    def not_used19(self):
        return <int8_t>(<int8_t>self.data[0].not_used19)
    @not_used19.setter
    def not_used19(self, value):
        self.data[0].not_used19 = value
    @property
    def not_used20(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used20)
    @not_used20.setter
    def not_used20(self, value):
        self.data[0].not_used20 = value
    @property
    def not_used21(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used21)
    @not_used21.setter
    def not_used21(self, value):
        self.data[0].not_used21 = value
    @property
    def not_used22(self):
        return <uint32_t>(<uint32_t>self.data[0].not_used22)
    @not_used22.setter
    def not_used22(self, value):
        self.data[0].not_used22 = value
    @property
    def something14(self):
        return <uint32_t>(<uint32_t>self.data[0].something14)
    @something14.setter
    def something14(self, value):
        self.data[0].something14 = value
    @property
    def something15(self):
        return <uint32_t>(<uint32_t>self.data[0].something15)
    @something15.setter
    def something15(self, value):
        self.data[0].something15 = value
    @property
    def appearance(self):
        cdef WrapAppearanceData ret = WrapAppearanceData.__new__(WrapAppearanceData)
        ret.data = &self.data[0].appearance
        return ret
    @appearance.setter
    def appearance(self, value):
        cdef WrapAppearanceData v = value
        self.data[0].appearance = v.data[0]
    @property
    def items(self):
        cdef WrapArray1 ret = WrapArray1.__new__(WrapArray1)
        ret.array = &self.data[0].items[0]
        return ret
    @items.setter
    def items(self, value):
        raise NotImplementedError()
    @property
    def max_hp_multiplier(self):
        return <float>(<float>self.data[0].max_hp_multiplier)
    @max_hp_multiplier.setter
    def max_hp_multiplier(self, value):
        self.data[0].max_hp_multiplier = value
    @property
    def shoot_speed(self):
        return <float>(<float>self.data[0].shoot_speed)
    @shoot_speed.setter
    def shoot_speed(self, value):
        self.data[0].shoot_speed = value
    @property
    def damage_multiplier(self):
        return <float>(<float>self.data[0].damage_multiplier)
    @damage_multiplier.setter
    def damage_multiplier(self, value):
        self.data[0].damage_multiplier = value
    @property
    def armor_multiplier(self):
        return <float>(<float>self.data[0].armor_multiplier)
    @armor_multiplier.setter
    def armor_multiplier(self, value):
        self.data[0].armor_multiplier = value
    @property
    def resi_multiplier(self):
        return <float>(<float>self.data[0].resi_multiplier)
    @resi_multiplier.setter
    def resi_multiplier(self, value):
        self.data[0].resi_multiplier = value
    @property
    def extra_item(self):
        cdef WrapItemWithExtra ret = WrapItemWithExtra.__new__(WrapItemWithExtra)
        ret.data = &self.data[0].extra_item
        return ret
    @extra_item.setter
    def extra_item(self, value):
        cdef WrapItemWithExtra v = value
        self.data[0].extra_item = v.data[0]
    @property
    def some_12b_p(self):
        return <uint32_t>(<uint32_t>self.data[0].some_12b_p)
    @some_12b_p.setter
    def some_12b_p(self, value):
        self.data[0].some_12b_p = value
    @property
    def some_vec(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some_vec_start
        return ret
    @some_vec.setter
    def some_vec(self, value):
        raise NotImplementedError()
    @property
    def id_vec_1(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].id_vec_1_start
        return ret
    @id_vec_1.setter
    def id_vec_1(self, value):
        raise NotImplementedError()
    @property
    def id_vec_2_end_old(self):
        return <uint32_t>(<uint32_t>self.data[0].id_vec_2_end_old)
    @id_vec_2_end_old.setter
    def id_vec_2_end_old(self, value):
        self.data[0].id_vec_2_end_old = value
    @property
    def id_vec_2(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].id_vec_2_start
        return ret
    @id_vec_2.setter
    def id_vec_2(self, value):
        raise NotImplementedError()
    @property
    def unknown_or_not_used4(self):
        return <uint32_t>(<uint32_t>self.data[0].unknown_or_not_used4)
    @unknown_or_not_used4.setter
    def unknown_or_not_used4(self, value):
        self.data[0].unknown_or_not_used4 = value
    @property
    def name(self):
        cdef int i = 0
        while i < 16:
            if self.data[0].name[i] == 0: break
            i += 1
        return filter_bytes(self.data[0].name[:i])
    @name.setter
    def name(self, value):
        cdef str v = value
        cdef bytes vv = v.encode('ascii', 'ignore')[:16]
        self.data[0].name = vv
    @property
    def something30(self):
        return <uint32_t>(<uint32_t>self.data[0].something30)
    @something30.setter
    def something30(self, value):
        self.data[0].something30 = value
    @property
    def something31(self):
        return <uint32_t>(<uint32_t>self.data[0].something31)
    @something31.setter
    def something31(self, value):
        self.data[0].something31 = value
    @property
    def something32(self):
        return <uint32_t>(<uint32_t>self.data[0].something32)
    @something32.setter
    def something32(self, value):
        self.data[0].something32 = value
    @property
    def something37(self):
        return <int8_t>(<int8_t>self.data[0].something37)
    @something37.setter
    def something37(self, value):
        self.data[0].something37 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapCriticalSection:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(CriticalSection))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(CriticalSection))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapCriticalSection c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapCriticalSection inst = WrapCriticalSection.__new__(WrapCriticalSection)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(CriticalSection))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(CriticalSection))
        self.data = <CriticalSection*>self.storage
    @property
    def DebugInfo(self):
        cdef WrapArray2 ret = WrapArray2.__new__(WrapArray2)
        ret.array = &(<int8_t*>self.data[0].DebugInfo)[0]
        return ret
    @DebugInfo.setter
    def DebugInfo(self, value):
        raise NotImplementedError()
    @property
    def LockCount(self):
        return <uint32_t>(<uint32_t>self.data[0].LockCount)
    @LockCount.setter
    def LockCount(self, value):
        self.data[0].LockCount = value
    @property
    def RecursionCount(self):
        return <uint32_t>(<uint32_t>self.data[0].RecursionCount)
    @RecursionCount.setter
    def RecursionCount(self, value):
        self.data[0].RecursionCount = value
    @property
    def OwningThread(self):
        return <uint32_t>(<uint32_t>self.data[0].OwningThread)
    @OwningThread.setter
    def OwningThread(self, value):
        self.data[0].OwningThread = value
    @property
    def LockSemaphore(self):
        return <uint32_t>(<uint32_t>self.data[0].LockSemaphore)
    @LockSemaphore.setter
    def LockSemaphore(self, value):
        self.data[0].LockSemaphore = value
    @property
    def SpinCount(self):
        return <uint32_t>(<uint32_t>self.data[0].SpinCount)
    @SpinCount.setter
    def SpinCount(self, value):
        self.data[0].SpinCount = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapColor:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Color))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Color))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapColor c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapColor inst = WrapColor.__new__(WrapColor)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Color))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(Color))
        self.data = <Color*>self.storage
    @property
    def r(self):
        return <uint8_t>(<uint8_t>self.data[0].r)
    @r.setter
    def r(self, value):
        self.data[0].r = value
    @property
    def g(self):
        return <uint8_t>(<uint8_t>self.data[0].g)
    @g.setter
    def g(self, value):
        self.data[0].g = value
    @property
    def b(self):
        return <uint8_t>(<uint8_t>self.data[0].b)
    @b.setter
    def b(self, value):
        self.data[0].b = value
    @property
    def a(self):
        return <uint8_t>(<uint8_t>self.data[0].a)
    @a.setter
    def a(self, value):
        self.data[0].a = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapField:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Field))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Field))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapField c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapField inst = WrapField.__new__(WrapField)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Field))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(Field))
        self.data = <Field*>self.storage
    @property
    def vtable(self):
        return <uint32_t>(<uint32_t>self.data[0].vtable)
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def f1(self):
        return <float>(<float>self.data[0].f1)
    @f1.setter
    def f1(self, value):
        self.data[0].f1 = value
    @property
    def f2(self):
        return <float>(<float>self.data[0].f2)
    @f2.setter
    def f2(self, value):
        self.data[0].f2 = value
    @property
    def f3(self):
        return <float>(<float>self.data[0].f3)
    @f3.setter
    def f3(self, value):
        self.data[0].f3 = value
    @property
    def a(self):
        return <uint32_t>(<uint32_t>self.data[0].a)
    @a.setter
    def a(self, value):
        self.data[0].a = value
    @property
    def b(self):
        return <uint32_t>(<uint32_t>self.data[0].b)
    @b.setter
    def b(self, value):
        self.data[0].b = value
    @property
    def data(self):
        cdef WrapArray3 ret = WrapArray3.__new__(WrapArray3)
        ret.array = &(<Color*>self.data[0].data)[0]
        return ret
    @data.setter
    def data(self, value):
        raise NotImplementedError()
    @property
    def size(self):
        return <uint32_t>(<uint32_t>self.data[0].size)
    @size.setter
    def size(self, value):
        self.data[0].size = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapChunkItemData:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(ChunkItemData))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(ChunkItemData))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapChunkItemData c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapChunkItemData inst = WrapChunkItemData.__new__(WrapChunkItemData)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(ChunkItemData))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(ChunkItemData))
        self.data = <ChunkItemData*>self.storage
    @property
    def item_data(self):
        cdef WrapItemData ret = WrapItemData.__new__(WrapItemData)
        ret.data = &self.data[0].item_data
        return ret
    @item_data.setter
    def item_data(self, value):
        cdef WrapItemData v = value
        self.data[0].item_data = v.data[0]
    @property
    def pos(self):
        cdef int64_t * ptr = &self.data[0].pos[0]
        return np.asarray(<int64_t[:3]>ptr).view(Vector3)
    @pos.setter
    def pos(self, value):
        self.data[0].pos = value
    @property
    def rotation(self):
        return <float>(<float>self.data[0].rotation)
    @rotation.setter
    def rotation(self, value):
        self.data[0].rotation = value
    @property
    def scale(self):
        return <float>(<float>self.data[0].scale)
    @scale.setter
    def scale(self, value):
        self.data[0].scale = value
    @property
    def something3(self):
        return <uint8_t>(<uint8_t>self.data[0].something3)
    @something3.setter
    def something3(self, value):
        self.data[0].something3 = value
    @property
    def drop_time(self):
        return <uint32_t>(<uint32_t>self.data[0].drop_time)
    @drop_time.setter
    def drop_time(self, value):
        self.data[0].drop_time = value
    @property
    def something5(self):
        return <uint32_t>(<uint32_t>self.data[0].something5)
    @something5.setter
    def something5(self, value):
        self.data[0].something5 = value
    @property
    def something6(self):
        return <uint32_t>(<uint32_t>self.data[0].something6)
    @something6.setter
    def something6(self, value):
        self.data[0].something6 = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapZone:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Zone))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Zone))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapZone c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapZone inst = WrapZone.__new__(WrapZone)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Zone))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(Zone))
        self.data = <Zone*>self.storage
    @property
    def vtable(self):
        return <int32_t>(<int32_t>self.data[0].vtable)
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def b(self):
        return <int32_t>(<int32_t>self.data[0].b)
    @b.setter
    def b(self, value):
        self.data[0].b = value
    @property
    def c(self):
        return <int32_t>(<int32_t>self.data[0].c)
    @c.setter
    def c(self, value):
        self.data[0].c = value
    @property
    def static_entities(self):
        cdef WrapStaticEntityVec ret = WrapStaticEntityVec.__new__(WrapStaticEntityVec)
        ret.data = &self.data[0].static_entities_start
        return ret
    @static_entities.setter
    def static_entities(self, value):
        raise NotImplementedError()
    @property
    def spawns(self):
        cdef WrapSpawnPtrVec ret = WrapSpawnPtrVec.__new__(WrapSpawnPtrVec)
        ret.data = &self.data[0].spawns_start
        return ret
    @spawns.setter
    def spawns(self, value):
        raise NotImplementedError()
    @property
    def some4(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some4_start
        return ret
    @some4.setter
    def some4(self, value):
        raise NotImplementedError()
    @property
    def items(self):
        cdef WrapChunkItemDataVec ret = WrapChunkItemDataVec.__new__(WrapChunkItemDataVec)
        ret.data = &self.data[0].items_start
        return ret
    @items.setter
    def items(self, value):
        raise NotImplementedError()
    @property
    def some9(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some9_start
        return ret
    @some9.setter
    def some9(self, value):
        raise NotImplementedError()
    @property
    def some8(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some8_start
        return ret
    @some8.setter
    def some8(self, value):
        raise NotImplementedError()
    @property
    def some7(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some7_start
        return ret
    @some7.setter
    def some7(self, value):
        raise NotImplementedError()
    @property
    def chunk_x(self):
        return <uint32_t>(<uint32_t>self.data[0].chunk_x)
    @chunk_x.setter
    def chunk_x(self, value):
        self.data[0].chunk_x = value
    @property
    def chunk_y(self):
        return <uint32_t>(<uint32_t>self.data[0].chunk_y)
    @chunk_y.setter
    def chunk_y(self, value):
        self.data[0].chunk_y = value
    @property
    def some2_20byte(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some2_20byte_start
        return ret
    @some2_20byte.setter
    def some2_20byte(self, value):
        raise NotImplementedError()
    @property
    def word74(self):
        return <uint8_t>(<uint8_t>self.data[0].word74)
    @word74.setter
    def word74(self, value):
        self.data[0].word74 = value
    @property
    def has_chunkitems(self):
        return <uint8_t>(<uint8_t>self.data[0].has_chunkitems)
    @has_chunkitems.setter
    def has_chunkitems(self, value):
        self.data[0].has_chunkitems = value
    @property
    def byte76(self):
        return <uint8_t>(<uint8_t>self.data[0].byte76)
    @byte76.setter
    def byte76(self, value):
        self.data[0].byte76 = value
    @property
    def dword78(self):
        return <uint32_t>(<uint32_t>self.data[0].dword78)
    @dword78.setter
    def dword78(self, value):
        self.data[0].dword78 = value
    @property
    def dword7C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword7C)
    @dword7C.setter
    def dword7C(self, value):
        self.data[0].dword7C = value
    @property
    def dword80(self):
        return <uint32_t>(<uint32_t>self.data[0].dword80)
    @dword80.setter
    def dword80(self, value):
        self.data[0].dword80 = value
    @property
    def byte84(self):
        return <uint8_t>(<uint8_t>self.data[0].byte84)
    @byte84.setter
    def byte84(self, value):
        self.data[0].byte84 = value
    @property
    def some5(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some5_start
        return ret
    @some5.setter
    def some5(self, value):
        raise NotImplementedError()
    @property
    def some6(self):
        cdef Wrapuint8Vec ret = Wrapuint8Vec.__new__(Wrapuint8Vec)
        ret.data = &self.data[0].some6_start
        return ret
    @some6.setter
    def some6(self, value):
        raise NotImplementedError()
    @property
    def start_something_dynamic_entities(self):
        return <uint32_t>(<uint32_t>self.data[0].start_something_dynamic_entities)
    @start_something_dynamic_entities.setter
    def start_something_dynamic_entities(self, value):
        self.data[0].start_something_dynamic_entities = value
    @property
    def dwordA4(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordA4)
    @dwordA4.setter
    def dwordA4(self, value):
        self.data[0].dwordA4 = value
    @property
    def fields(self):
        cdef WrapArray4 ret = WrapArray4.__new__(WrapArray4)
        ret.array = &(<Field*>self.data[0].fields)[0]
        return ret
    @fields.setter
    def fields(self, value):
        raise NotImplementedError()
    @property
    def other_chunk_data(self):
        return <uint32_t>(<uint32_t>self.data[0].other_chunk_data)
    @other_chunk_data.setter
    def other_chunk_data(self, value):
        self.data[0].other_chunk_data = value
    @property
    def crit_sec(self):
        cdef WrapCriticalSection ret = WrapCriticalSection.__new__(WrapCriticalSection)
        ret.data = &self.data[0].crit_sec
        return ret
    @crit_sec.setter
    def crit_sec(self, value):
        cdef WrapCriticalSection v = value
        self.data[0].crit_sec = v.data[0]
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapSomethingCreature:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(SomethingCreature))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(SomethingCreature))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapSomethingCreature c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapSomethingCreature inst = WrapSomethingCreature.__new__(WrapSomethingCreature)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(SomethingCreature))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(SomethingCreature))
        self.data = <SomethingCreature*>self.storage
    @property
    def dword0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword0)
    @dword0.setter
    def dword0(self, value):
        self.data[0].dword0 = value
    @property
    def dword4(self):
        return <uint32_t>(<uint32_t>self.data[0].dword4)
    @dword4.setter
    def dword4(self, value):
        self.data[0].dword4 = value
    @property
    def dword8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword8)
    @dword8.setter
    def dword8(self, value):
        self.data[0].dword8 = value
    @property
    def dwordC(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordC)
    @dwordC.setter
    def dwordC(self, value):
        self.data[0].dwordC = value
    @property
    def dword10(self):
        return <uint32_t>(<uint32_t>self.data[0].dword10)
    @dword10.setter
    def dword10(self, value):
        self.data[0].dword10 = value
    @property
    def dword14(self):
        return <uint32_t>(<uint32_t>self.data[0].dword14)
    @dword14.setter
    def dword14(self, value):
        self.data[0].dword14 = value
    @property
    def dword18(self):
        return <uint32_t>(<uint32_t>self.data[0].dword18)
    @dword18.setter
    def dword18(self, value):
        self.data[0].dword18 = value
    @property
    def dword1C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1C)
    @dword1C.setter
    def dword1C(self, value):
        self.data[0].dword1C = value
    @property
    def dword20(self):
        return <uint32_t>(<uint32_t>self.data[0].dword20)
    @dword20.setter
    def dword20(self, value):
        self.data[0].dword20 = value
    @property
    def dword24(self):
        return <uint32_t>(<uint32_t>self.data[0].dword24)
    @dword24.setter
    def dword24(self, value):
        self.data[0].dword24 = value
    @property
    def dword28(self):
        return <uint32_t>(<uint32_t>self.data[0].dword28)
    @dword28.setter
    def dword28(self, value):
        self.data[0].dword28 = value
    @property
    def dword2C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword2C)
    @dword2C.setter
    def dword2C(self, value):
        self.data[0].dword2C = value
    @property
    def dword30(self):
        return <uint32_t>(<uint32_t>self.data[0].dword30)
    @dword30.setter
    def dword30(self, value):
        self.data[0].dword30 = value
    @property
    def dword34(self):
        return <uint32_t>(<uint32_t>self.data[0].dword34)
    @dword34.setter
    def dword34(self, value):
        self.data[0].dword34 = value
    @property
    def dword38(self):
        return <uint32_t>(<uint32_t>self.data[0].dword38)
    @dword38.setter
    def dword38(self, value):
        self.data[0].dword38 = value
    @property
    def dword3C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword3C)
    @dword3C.setter
    def dword3C(self, value):
        self.data[0].dword3C = value
    @property
    def dword40(self):
        return <uint32_t>(<uint32_t>self.data[0].dword40)
    @dword40.setter
    def dword40(self, value):
        self.data[0].dword40 = value
    @property
    def dword44(self):
        return <uint32_t>(<uint32_t>self.data[0].dword44)
    @dword44.setter
    def dword44(self, value):
        self.data[0].dword44 = value
    @property
    def dword48(self):
        return <uint32_t>(<uint32_t>self.data[0].dword48)
    @dword48.setter
    def dword48(self, value):
        self.data[0].dword48 = value
    @property
    def dword4C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword4C)
    @dword4C.setter
    def dword4C(self, value):
        self.data[0].dword4C = value
    @property
    def dword50(self):
        return <uint32_t>(<uint32_t>self.data[0].dword50)
    @dword50.setter
    def dword50(self, value):
        self.data[0].dword50 = value
    @property
    def dword54(self):
        return <uint32_t>(<uint32_t>self.data[0].dword54)
    @dword54.setter
    def dword54(self, value):
        self.data[0].dword54 = value
    @property
    def dword58(self):
        return <uint32_t>(<uint32_t>self.data[0].dword58)
    @dword58.setter
    def dword58(self, value):
        self.data[0].dword58 = value
    @property
    def dword5C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword5C)
    @dword5C.setter
    def dword5C(self, value):
        self.data[0].dword5C = value
    @property
    def dword60(self):
        return <uint32_t>(<uint32_t>self.data[0].dword60)
    @dword60.setter
    def dword60(self, value):
        self.data[0].dword60 = value
    @property
    def dword64(self):
        return <uint32_t>(<uint32_t>self.data[0].dword64)
    @dword64.setter
    def dword64(self, value):
        self.data[0].dword64 = value
    @property
    def dword68(self):
        return <uint32_t>(<uint32_t>self.data[0].dword68)
    @dword68.setter
    def dword68(self, value):
        self.data[0].dword68 = value
    @property
    def dword6C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword6C)
    @dword6C.setter
    def dword6C(self, value):
        self.data[0].dword6C = value
    @property
    def dword70(self):
        return <uint32_t>(<uint32_t>self.data[0].dword70)
    @dword70.setter
    def dword70(self, value):
        self.data[0].dword70 = value
    @property
    def dword74(self):
        return <uint32_t>(<uint32_t>self.data[0].dword74)
    @dword74.setter
    def dword74(self, value):
        self.data[0].dword74 = value
    @property
    def dword78(self):
        return <uint32_t>(<uint32_t>self.data[0].dword78)
    @dword78.setter
    def dword78(self, value):
        self.data[0].dword78 = value
    @property
    def dword7C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword7C)
    @dword7C.setter
    def dword7C(self, value):
        self.data[0].dword7C = value
    @property
    def dword80(self):
        return <uint32_t>(<uint32_t>self.data[0].dword80)
    @dword80.setter
    def dword80(self, value):
        self.data[0].dword80 = value
    @property
    def dword84(self):
        return <uint32_t>(<uint32_t>self.data[0].dword84)
    @dword84.setter
    def dword84(self, value):
        self.data[0].dword84 = value
    @property
    def dword88(self):
        return <uint32_t>(<uint32_t>self.data[0].dword88)
    @dword88.setter
    def dword88(self, value):
        self.data[0].dword88 = value
    @property
    def dword8C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword8C)
    @dword8C.setter
    def dword8C(self, value):
        self.data[0].dword8C = value
    @property
    def dword90(self):
        return <uint32_t>(<uint32_t>self.data[0].dword90)
    @dword90.setter
    def dword90(self, value):
        self.data[0].dword90 = value
    @property
    def dword94(self):
        return <uint32_t>(<uint32_t>self.data[0].dword94)
    @dword94.setter
    def dword94(self, value):
        self.data[0].dword94 = value
    @property
    def dword98(self):
        return <uint32_t>(<uint32_t>self.data[0].dword98)
    @dword98.setter
    def dword98(self, value):
        self.data[0].dword98 = value
    @property
    def dword9C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword9C)
    @dword9C.setter
    def dword9C(self, value):
        self.data[0].dword9C = value
    @property
    def dwordA0(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordA0)
    @dwordA0.setter
    def dwordA0(self, value):
        self.data[0].dwordA0 = value
    @property
    def dwordA4(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordA4)
    @dwordA4.setter
    def dwordA4(self, value):
        self.data[0].dwordA4 = value
    @property
    def dwordA8(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordA8)
    @dwordA8.setter
    def dwordA8(self, value):
        self.data[0].dwordA8 = value
    @property
    def dwordAC(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordAC)
    @dwordAC.setter
    def dwordAC(self, value):
        self.data[0].dwordAC = value
    @property
    def dwordB0(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordB0)
    @dwordB0.setter
    def dwordB0(self, value):
        self.data[0].dwordB0 = value
    @property
    def dwordB4(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordB4)
    @dwordB4.setter
    def dwordB4(self, value):
        self.data[0].dwordB4 = value
    @property
    def dwordB8(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordB8)
    @dwordB8.setter
    def dwordB8(self, value):
        self.data[0].dwordB8 = value
    @property
    def dwordBC(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordBC)
    @dwordBC.setter
    def dwordBC(self, value):
        self.data[0].dwordBC = value
    @property
    def dwordC4(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordC4)
    @dwordC4.setter
    def dwordC4(self, value):
        self.data[0].dwordC4 = value
    @property
    def dwordC8(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordC8)
    @dwordC8.setter
    def dwordC8(self, value):
        self.data[0].dwordC8 = value
    @property
    def dwordCC(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordCC)
    @dwordCC.setter
    def dwordCC(self, value):
        self.data[0].dwordCC = value
    @property
    def dwordD0(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordD0)
    @dwordD0.setter
    def dwordD0(self, value):
        self.data[0].dwordD0 = value
    @property
    def dwordD4(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordD4)
    @dwordD4.setter
    def dwordD4(self, value):
        self.data[0].dwordD4 = value
    @property
    def dwordD8(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordD8)
    @dwordD8.setter
    def dwordD8(self, value):
        self.data[0].dwordD8 = value
    @property
    def dwordDC(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordDC)
    @dwordDC.setter
    def dwordDC(self, value):
        self.data[0].dwordDC = value
    @property
    def dwordE4(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordE4)
    @dwordE4.setter
    def dwordE4(self, value):
        self.data[0].dwordE4 = value
    @property
    def dwordE8(self):
        return <uint32_t>(<uint32_t>self.data[0].dwordE8)
    @dwordE8.setter
    def dwordE8(self, value):
        self.data[0].dwordE8 = value
    @property
    def dword86C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword86C)
    @dword86C.setter
    def dword86C(self, value):
        self.data[0].dword86C = value
    @property
    def dword870(self):
        return <uint32_t>(<uint32_t>self.data[0].dword870)
    @dword870.setter
    def dword870(self, value):
        self.data[0].dword870 = value
    @property
    def dword874(self):
        return <uint32_t>(<uint32_t>self.data[0].dword874)
    @dword874.setter
    def dword874(self, value):
        self.data[0].dword874 = value
    @property
    def byte878(self):
        return <uint8_t>(<uint8_t>self.data[0].byte878)
    @byte878.setter
    def byte878(self, value):
        self.data[0].byte878 = value
    @property
    def dword880(self):
        return <uint32_t>(<uint32_t>self.data[0].dword880)
    @dword880.setter
    def dword880(self, value):
        self.data[0].dword880 = value
    @property
    def dword884(self):
        return <uint32_t>(<uint32_t>self.data[0].dword884)
    @dword884.setter
    def dword884(self, value):
        self.data[0].dword884 = value
    @property
    def dword888(self):
        return <uint32_t>(<uint32_t>self.data[0].dword888)
    @dword888.setter
    def dword888(self, value):
        self.data[0].dword888 = value
    @property
    def dword88C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword88C)
    @dword88C.setter
    def dword88C(self, value):
        self.data[0].dword88C = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapCreature:
    def get_addr(self):
        return <uintptr_t>self.data
    def __bytes__(self):
        cdef bytes ret = (<char*>(self.data))[:sizeof(self.data[0])]
        return ret
    def read(self, ByteReader reader):
        reader.read_c(self.data, sizeof(Creature))
    def write(self, ByteWriter writer):
        writer.write_c(self.data, sizeof(Creature))
    def cast(self, object klass):
        cdef object inst = klass.__new__(klass)
        cdef WrapCreature c = inst
        c.data = self.data
        return inst
    def copy(self):
        cdef WrapCreature inst = WrapCreature.__new__(WrapCreature)
        inst.alloc()
        memcpy(inst.data, self.data, sizeof(Creature))
        return inst
    def __init__(self):
        self.alloc()
    def __dealloc__(self):
        if self.storage != NULL:
            PyMem_Free(self.storage)
    cdef void alloc(self):
        self.storage = PyMem_Malloc(sizeof(Creature))
        self.data = <Creature*>self.storage
    @property
    def vtable(self):
        return <uint32_t>(<uint32_t>self.data[0].vtable)
    @vtable.setter
    def vtable(self, value):
        self.data[0].vtable = value
    @property
    def f4(self):
        return <uint8_t[:4]>(<uint8_t*>self.data[0].f4)
    @f4.setter
    def f4(self, value):
        raise NotImplementedError()
    @property
    def entity_id(self):
        return <uint64_t>(<uint64_t>self.data[0].entity_id)
    @entity_id.setter
    def entity_id(self, value):
        self.data[0].entity_id = value
    @property
    def entity_data(self):
        cdef WrapEntityData ret = WrapEntityData.__new__(WrapEntityData)
        ret.data = &self.data[0].entity_data
        return ret
    @entity_data.setter
    def entity_data(self, value):
        cdef WrapEntityData v = value
        self.data[0].entity_data = v.data[0]
    @property
    def ptr32_1178(self):
        return <uint32_t>(<uint32_t>self.data[0].ptr32_1178)
    @ptr32_1178.setter
    def ptr32_1178(self, value):
        self.data[0].ptr32_1178 = value
    @property
    def dword117C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword117C)
    @dword117C.setter
    def dword117C(self, value):
        self.data[0].dword117C = value
    @property
    def dword1180(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1180)
    @dword1180.setter
    def dword1180(self, value):
        self.data[0].dword1180 = value
    @property
    def dword1184(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1184)
    @dword1184.setter
    def dword1184(self, value):
        self.data[0].dword1184 = value
    @property
    def dword1188(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1188)
    @dword1188.setter
    def dword1188(self, value):
        self.data[0].dword1188 = value
    @property
    def dword118C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword118C)
    @dword118C.setter
    def dword118C(self, value):
        self.data[0].dword118C = value
    @property
    def dword1190(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1190)
    @dword1190.setter
    def dword1190(self, value):
        self.data[0].dword1190 = value
    @property
    def float1194(self):
        return <float>(<float>self.data[0].float1194)
    @float1194.setter
    def float1194(self, value):
        self.data[0].float1194 = value
    @property
    def float1198(self):
        return <float>(<float>self.data[0].float1198)
    @float1198.setter
    def float1198(self, value):
        self.data[0].float1198 = value
    @property
    def dword119C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword119C)
    @dword119C.setter
    def dword119C(self, value):
        self.data[0].dword119C = value
    @property
    def f11A0(self):
        return <uint8_t[:12]>(<uint8_t*>self.data[0].f11A0)
    @f11A0.setter
    def f11A0(self, value):
        raise NotImplementedError()
    @property
    def mapptr24_11AC(self):
        return <uint32_t>(<uint32_t>self.data[0].mapptr24_11AC)
    @mapptr24_11AC.setter
    def mapptr24_11AC(self, value):
        self.data[0].mapptr24_11AC = value
    @property
    def dword11B0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11B0)
    @dword11B0.setter
    def dword11B0(self, value):
        self.data[0].dword11B0 = value
    @property
    def mapptr24_11B4(self):
        return <uint32_t>(<uint32_t>self.data[0].mapptr24_11B4)
    @mapptr24_11B4.setter
    def mapptr24_11B4(self, value):
        self.data[0].mapptr24_11B4 = value
    @property
    def dword11B8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11B8)
    @dword11B8.setter
    def dword11B8(self, value):
        self.data[0].dword11B8 = value
    @property
    def f11BC(self):
        return <uint8_t[:4]>(<uint8_t*>self.data[0].f11BC)
    @f11BC.setter
    def f11BC(self, value):
        raise NotImplementedError()
    @property
    def dword11C0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11C0)
    @dword11C0.setter
    def dword11C0(self, value):
        self.data[0].dword11C0 = value
    @property
    def dword11C4(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11C4)
    @dword11C4.setter
    def dword11C4(self, value):
        self.data[0].dword11C4 = value
    @property
    def dword11C8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11C8)
    @dword11C8.setter
    def dword11C8(self, value):
        self.data[0].dword11C8 = value
    @property
    def dword11CC(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11CC)
    @dword11CC.setter
    def dword11CC(self, value):
        self.data[0].dword11CC = value
    @property
    def dword11D0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11D0)
    @dword11D0.setter
    def dword11D0(self, value):
        self.data[0].dword11D0 = value
    @property
    def dword11D4(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11D4)
    @dword11D4.setter
    def dword11D4(self, value):
        self.data[0].dword11D4 = value
    @property
    def dword11D8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword11D8)
    @dword11D8.setter
    def dword11D8(self, value):
        self.data[0].dword11D8 = value
    @property
    def item_with_extra(self):
        cdef WrapItemWithExtra ret = WrapItemWithExtra.__new__(WrapItemWithExtra)
        ret.data = &self.data[0].item_with_extra
        return ret
    @item_with_extra.setter
    def item_with_extra(self, value):
        cdef WrapItemWithExtra v = value
        self.data[0].item_with_extra = v.data[0]
    @property
    def ptr308_130C(self):
        return <uint32_t>(<uint32_t>self.data[0].ptr308_130C)
    @ptr308_130C.setter
    def ptr308_130C(self, value):
        self.data[0].ptr308_130C = value
    @property
    def dword1310(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1310)
    @dword1310.setter
    def dword1310(self, value):
        self.data[0].dword1310 = value
    @property
    def dword1314(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1314)
    @dword1314.setter
    def dword1314(self, value):
        self.data[0].dword1314 = value
    @property
    def dword1318(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1318)
    @dword1318.setter
    def dword1318(self, value):
        self.data[0].dword1318 = value
    @property
    def f131C(self):
        return <uint8_t[:52]>(<uint8_t*>self.data[0].f131C)
    @f131C.setter
    def f131C(self, value):
        raise NotImplementedError()
    @property
    def dword1350(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1350)
    @dword1350.setter
    def dword1350(self, value):
        self.data[0].dword1350 = value
    @property
    def dword1354(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1354)
    @dword1354.setter
    def dword1354(self, value):
        self.data[0].dword1354 = value
    @property
    def dword1358(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1358)
    @dword1358.setter
    def dword1358(self, value):
        self.data[0].dword1358 = value
    @property
    def dword135C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword135C)
    @dword135C.setter
    def dword135C(self, value):
        self.data[0].dword135C = value
    @property
    def dword1360(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1360)
    @dword1360.setter
    def dword1360(self, value):
        self.data[0].dword1360 = value
    @property
    def dword1364(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1364)
    @dword1364.setter
    def dword1364(self, value):
        self.data[0].dword1364 = value
    @property
    def f1368(self):
        return <uint8_t[:12]>(<uint8_t*>self.data[0].f1368)
    @f1368.setter
    def f1368(self, value):
        raise NotImplementedError()
    @property
    def dword1374(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1374)
    @dword1374.setter
    def dword1374(self, value):
        self.data[0].dword1374 = value
    @property
    def dword1378(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1378)
    @dword1378.setter
    def dword1378(self, value):
        self.data[0].dword1378 = value
    @property
    def dword137C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword137C)
    @dword137C.setter
    def dword137C(self, value):
        self.data[0].dword137C = value
    @property
    def f1380(self):
        return <uint8_t[:24]>(<uint8_t*>self.data[0].f1380)
    @f1380.setter
    def f1380(self, value):
        raise NotImplementedError()
    @property
    def dword1398(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1398)
    @dword1398.setter
    def dword1398(self, value):
        self.data[0].dword1398 = value
    @property
    def mapptr24_139C(self):
        return <uint32_t>(<uint32_t>self.data[0].mapptr24_139C)
    @mapptr24_139C.setter
    def mapptr24_139C(self, value):
        self.data[0].mapptr24_139C = value
    @property
    def dword13A0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13A0)
    @dword13A0.setter
    def dword13A0(self, value):
        self.data[0].dword13A0 = value
    @property
    def creature_map(self):
        return <uint32_t>(<uint32_t>self.data[0].creature_map)
    @creature_map.setter
    def creature_map(self, value):
        self.data[0].creature_map = value
    @property
    def dword13A8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13A8)
    @dword13A8.setter
    def dword13A8(self, value):
        self.data[0].dword13A8 = value
    @property
    def creature_map2(self):
        return <uint32_t>(<uint32_t>self.data[0].creature_map2)
    @creature_map2.setter
    def creature_map2(self, value):
        self.data[0].creature_map2 = value
    @property
    def dword13B0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13B0)
    @dword13B0.setter
    def dword13B0(self, value):
        self.data[0].dword13B0 = value
    @property
    def dword13B4(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13B4)
    @dword13B4.setter
    def dword13B4(self, value):
        self.data[0].dword13B4 = value
    @property
    def byte13B8(self):
        return <uint8_t>(<uint8_t>self.data[0].byte13B8)
    @byte13B8.setter
    def byte13B8(self, value):
        self.data[0].byte13B8 = value
    @property
    def f13B9(self):
        return <uint8_t[:3]>(<uint8_t*>self.data[0].f13B9)
    @f13B9.setter
    def f13B9(self, value):
        raise NotImplementedError()
    @property
    def dword13BC(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13BC)
    @dword13BC.setter
    def dword13BC(self, value):
        self.data[0].dword13BC = value
    @property
    def byte13C0(self):
        return <uint8_t>(<uint8_t>self.data[0].byte13C0)
    @byte13C0.setter
    def byte13C0(self, value):
        self.data[0].byte13C0 = value
    @property
    def f13C1(self):
        return <uint8_t[:3]>(<uint8_t*>self.data[0].f13C1)
    @f13C1.setter
    def f13C1(self, value):
        raise NotImplementedError()
    @property
    def dword13C4(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13C4)
    @dword13C4.setter
    def dword13C4(self, value):
        self.data[0].dword13C4 = value
    @property
    def dword13C8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13C8)
    @dword13C8.setter
    def dword13C8(self, value):
        self.data[0].dword13C8 = value
    @property
    def dword13CC(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13CC)
    @dword13CC.setter
    def dword13CC(self, value):
        self.data[0].dword13CC = value
    @property
    def dword13D0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13D0)
    @dword13D0.setter
    def dword13D0(self, value):
        self.data[0].dword13D0 = value
    @property
    def dword13D4(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13D4)
    @dword13D4.setter
    def dword13D4(self, value):
        self.data[0].dword13D4 = value
    @property
    def dword13D8(self):
        return <float>(<float>self.data[0].dword13D8)
    @dword13D8.setter
    def dword13D8(self, value):
        self.data[0].dword13D8 = value
    @property
    def dword13DC(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13DC)
    @dword13DC.setter
    def dword13DC(self, value):
        self.data[0].dword13DC = value
    @property
    def dword13E0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13E0)
    @dword13E0.setter
    def dword13E0(self, value):
        self.data[0].dword13E0 = value
    @property
    def behaviour(self):
        return <uint32_t>(<uint32_t>self.data[0].behaviour)
    @behaviour.setter
    def behaviour(self, value):
        self.data[0].behaviour = value
    @property
    def dword13E8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13E8)
    @dword13E8.setter
    def dword13E8(self, value):
        self.data[0].dword13E8 = value
    @property
    def dword13EC(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13EC)
    @dword13EC.setter
    def dword13EC(self, value):
        self.data[0].dword13EC = value
    @property
    def dword13F0(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13F0)
    @dword13F0.setter
    def dword13F0(self, value):
        self.data[0].dword13F0 = value
    @property
    def dword13F4(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13F4)
    @dword13F4.setter
    def dword13F4(self, value):
        self.data[0].dword13F4 = value
    @property
    def dword13F8(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13F8)
    @dword13F8.setter
    def dword13F8(self, value):
        self.data[0].dword13F8 = value
    @property
    def dword13FC(self):
        return <uint32_t>(<uint32_t>self.data[0].dword13FC)
    @dword13FC.setter
    def dword13FC(self, value):
        self.data[0].dword13FC = value
    @property
    def dword1400(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1400)
    @dword1400.setter
    def dword1400(self, value):
        self.data[0].dword1400 = value
    @property
    def dword1404(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1404)
    @dword1404.setter
    def dword1404(self, value):
        self.data[0].dword1404 = value
    @property
    def dword1408(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1408)
    @dword1408.setter
    def dword1408(self, value):
        self.data[0].dword1408 = value
    @property
    def mapptr52_140C(self):
        return <uint32_t>(<uint32_t>self.data[0].mapptr52_140C)
    @mapptr52_140C.setter
    def mapptr52_140C(self, value):
        self.data[0].mapptr52_140C = value
    @property
    def dword1410(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1410)
    @dword1410.setter
    def dword1410(self, value):
        self.data[0].dword1410 = value
    @property
    def mapptr28_1414(self):
        return <uint32_t>(<uint32_t>self.data[0].mapptr28_1414)
    @mapptr28_1414.setter
    def mapptr28_1414(self, value):
        self.data[0].mapptr28_1414 = value
    @property
    def dword1418(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1418)
    @dword1418.setter
    def dword1418(self, value):
        self.data[0].dword1418 = value
    @property
    def dword141C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword141C)
    @dword141C.setter
    def dword141C(self, value):
        self.data[0].dword141C = value
    @property
    def dword1420(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1420)
    @dword1420.setter
    def dword1420(self, value):
        self.data[0].dword1420 = value
    @property
    def dword1424(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1424)
    @dword1424.setter
    def dword1424(self, value):
        self.data[0].dword1424 = value
    @property
    def f1428(self):
        return <uint8_t[:48]>(<uint8_t*>self.data[0].f1428)
    @f1428.setter
    def f1428(self, value):
        raise NotImplementedError()
    @property
    def dword1458(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1458)
    @dword1458.setter
    def dword1458(self, value):
        self.data[0].dword1458 = value
    @property
    def dword145C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword145C)
    @dword145C.setter
    def dword145C(self, value):
        self.data[0].dword145C = value
    @property
    def ptr20_1460(self):
        return <uint32_t>(<uint32_t>self.data[0].ptr20_1460)
    @ptr20_1460.setter
    def ptr20_1460(self, value):
        self.data[0].ptr20_1460 = value
    @property
    def dword1464(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1464)
    @dword1464.setter
    def dword1464(self, value):
        self.data[0].dword1464 = value
    @property
    def mapptr20_1468(self):
        return <uint32_t>(<uint32_t>self.data[0].mapptr20_1468)
    @mapptr20_1468.setter
    def mapptr20_1468(self, value):
        self.data[0].mapptr20_1468 = value
    @property
    def dword146C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword146C)
    @dword146C.setter
    def dword146C(self, value):
        self.data[0].dword146C = value
    @property
    def ptr20_1470(self):
        return <uint32_t>(<uint32_t>self.data[0].ptr20_1470)
    @ptr20_1470.setter
    def ptr20_1470(self, value):
        self.data[0].ptr20_1470 = value
    @property
    def dword1474(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1474)
    @dword1474.setter
    def dword1474(self, value):
        self.data[0].dword1474 = value
    @property
    def dword1478(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1478)
    @dword1478.setter
    def dword1478(self, value):
        self.data[0].dword1478 = value
    @property
    def dword147C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword147C)
    @dword147C.setter
    def dword147C(self, value):
        self.data[0].dword147C = value
    @property
    def dword1480(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1480)
    @dword1480.setter
    def dword1480(self, value):
        self.data[0].dword1480 = value
    @property
    def dword1484(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1484)
    @dword1484.setter
    def dword1484(self, value):
        self.data[0].dword1484 = value
    @property
    def dword1488(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1488)
    @dword1488.setter
    def dword1488(self, value):
        self.data[0].dword1488 = value
    @property
    def dword148C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword148C)
    @dword148C.setter
    def dword148C(self, value):
        self.data[0].dword148C = value
    @property
    def dword1490(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1490)
    @dword1490.setter
    def dword1490(self, value):
        self.data[0].dword1490 = value
    @property
    def dword1494(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1494)
    @dword1494.setter
    def dword1494(self, value):
        self.data[0].dword1494 = value
    @property
    def som_c(self):
        cdef WrapSomethingCreature ret = WrapSomethingCreature.__new__(WrapSomethingCreature)
        ret.data = &self.data[0].som_c
        return ret
    @som_c.setter
    def som_c(self, value):
        cdef WrapSomethingCreature v = value
        self.data[0].som_c = v.data[0]
    @property
    def dword1D28(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1D28)
    @dword1D28.setter
    def dword1D28(self, value):
        self.data[0].dword1D28 = value
    @property
    def float1D2C(self):
        return <uint32_t>(<uint32_t>self.data[0].float1D2C)
    @float1D2C.setter
    def float1D2C(self, value):
        self.data[0].float1D2C = value
    @property
    def f1D30(self):
        return <uint8_t[:8]>(<uint8_t*>self.data[0].f1D30)
    @f1D30.setter
    def f1D30(self, value):
        raise NotImplementedError()
    @property
    def byte1D38(self):
        return <uint8_t>(<uint8_t>self.data[0].byte1D38)
    @byte1D38.setter
    def byte1D38(self, value):
        self.data[0].byte1D38 = value
    @property
    def f1D39(self):
        return <uint8_t[:3]>(<uint8_t*>self.data[0].f1D39)
    @f1D39.setter
    def f1D39(self, value):
        raise NotImplementedError()
    @property
    def dword1D3C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1D3C)
    @dword1D3C.setter
    def dword1D3C(self, value):
        self.data[0].dword1D3C = value
    @property
    def dword1D40(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1D40)
    @dword1D40.setter
    def dword1D40(self, value):
        self.data[0].dword1D40 = value
    @property
    def dword1D44(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1D44)
    @dword1D44.setter
    def dword1D44(self, value):
        self.data[0].dword1D44 = value
    @property
    def word1D48(self):
        return <uint16_t>(<uint16_t>self.data[0].word1D48)
    @word1D48.setter
    def word1D48(self, value):
        self.data[0].word1D48 = value
    @property
    def f1D4A(self):
        return <uint8_t[:2]>(<uint8_t*>self.data[0].f1D4A)
    @f1D4A.setter
    def f1D4A(self, value):
        raise NotImplementedError()
    @property
    def dword1D4C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1D4C)
    @dword1D4C.setter
    def dword1D4C(self, value):
        self.data[0].dword1D4C = value
    @property
    def dword1D50(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1D50)
    @dword1D50.setter
    def dword1D50(self, value):
        self.data[0].dword1D50 = value
    @property
    def word1D54(self):
        return <uint16_t>(<uint16_t>self.data[0].word1D54)
    @word1D54.setter
    def word1D54(self, value):
        self.data[0].word1D54 = value
    @property
    def byte1D56(self):
        return <uint8_t>(<uint8_t>self.data[0].byte1D56)
    @byte1D56.setter
    def byte1D56(self, value):
        self.data[0].byte1D56 = value
    @property
    def f1D57(self):
        return <uint8_t[:1]>(<uint8_t*>self.data[0].f1D57)
    @f1D57.setter
    def f1D57(self, value):
        raise NotImplementedError()
    @property
    def word1D58(self):
        return <uint16_t>(<uint16_t>self.data[0].word1D58)
    @word1D58.setter
    def word1D58(self, value):
        self.data[0].word1D58 = value
    @property
    def f1D5A(self):
        return <uint8_t[:2]>(<uint8_t*>self.data[0].f1D5A)
    @f1D5A.setter
    def f1D5A(self, value):
        raise NotImplementedError()
    @property
    def char1D5C(self):
        return <int8_t[:256]>(<int8_t*>self.data[0].char1D5C)
    @char1D5C.setter
    def char1D5C(self, value):
        raise NotImplementedError()
    @property
    def dword1E5C(self):
        return <uint32_t>(<uint32_t>self.data[0].dword1E5C)
    @dword1E5C.setter
    def dword1E5C(self, value):
        self.data[0].dword1E5C = value
    def reset(self):
        memset(self.data, 0, sizeof(self.data[0]))
cdef class WrapArray0:
    def __getitem__(self, uint32_t index):
        if index >= 32: raise IndexError()
        cdef WrapItemUpgrade ret = WrapItemUpgrade()
        ret.data = &self.array[index]
        return ret
    def __len__(self):
        return 32
cdef class WrapArray1:
    def __getitem__(self, uint32_t index):
        if index >= 13: raise IndexError()
        cdef WrapItemData ret = WrapItemData()
        ret.data = &self.array[index]
        return ret
    def __len__(self):
        return 13
cdef class WrapArray2:
    def __getitem__(self, uint32_t index):
        return self.array[index]
cdef class WrapArray3:
    def __getitem__(self, uint32_t index):
        cdef WrapColor ret = WrapColor()
        ret.data = &self.array[index]
        return ret
cdef class WrapArray4:
    def __getitem__(self, uint32_t index):
        cdef WrapField ret = WrapField()
        ret.data = &self.array[index]
        return ret
cdef class WrapItemWithHeaderVec:
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(ItemWithHeader) * index
        if val >= end: raise IndexError()
        cdef ItemWithHeader * res = <ItemWithHeader*>val
        cdef WrapItemWithHeader ret = WrapItemWithHeader()
        ret.data = &res[0]
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(ItemWithHeader)
cdef class WrapItemWithHeaderListVec:
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(ItemWithHeaderList) * index
        if val >= end: raise IndexError()
        cdef ItemWithHeaderList * res = <ItemWithHeaderList*>val
        cdef WrapItemWithHeaderList ret = WrapItemWithHeaderList()
        ret.data = &res[0]
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(ItemWithHeaderList)
cdef class Wrapuint8Vec:
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(uint8_t) * index
        if val >= end: raise IndexError()
        cdef uint8_t * res = <uint8_t*>val
        return res[0]
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(uint8_t)
cdef class WrapStaticEntityVec:
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(StaticEntity) * index
        if val >= end: raise IndexError()
        cdef StaticEntity * res = <StaticEntity*>val
        cdef WrapStaticEntity ret = WrapStaticEntity()
        ret.data = &res[0]
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(StaticEntity)
cdef class WrapSpawnPtrVec:
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(uint32_t) * index
        if val >= end: raise IndexError()
        cdef Spawn * res = <Spawn*>(<uint32_t*>val)[0]
        cdef WrapSpawn ret = WrapSpawn()
        ret.data = &res[0]
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(uint32_t)
cdef class WrapChunkItemDataVec:
    def get_data(self): return (self.data[0], self.data[1], self.data[2])
    def clear(self):
        self.data[1] = self.data[0]
    def __getitem__(self, uint32_t index):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        val += sizeof(ChunkItemData) * index
        if val >= end: raise IndexError()
        cdef ChunkItemData * res = <ChunkItemData*>val
        cdef WrapChunkItemData ret = WrapChunkItemData()
        ret.data = &res[0]
        return ret
    def __len__(self):
        cdef char * val = <char*>self.data[0]
        cdef char * end = <char*>self.data[1]
        return <uint32_t>(end - val) / sizeof(ChunkItemData)
cpdef inline bint is_pos_set(uint64_t mask):
    return mask & (<uint64_t>1 << 0) != 0


cpdef inline bint is_orient_set(uint64_t mask):
    return mask & (<uint64_t>1 << 1) != 0


cpdef inline bint is_vel_set(uint64_t mask):
    return mask & (<uint64_t>1 << 2) != 0


cpdef inline bint is_accel_set(uint64_t mask):
    return mask & (<uint64_t>1 << 3) != 0


cpdef inline bint is_extra_vel_set(uint64_t mask):
    return mask & (<uint64_t>1 << 4) != 0


cpdef inline bint is_look_pitch_set(uint64_t mask):
    return mask & (<uint64_t>1 << 5) != 0


cpdef inline bint is_physics_set(uint64_t mask):
    return mask & (<uint64_t>1 << 6) != 0


cpdef inline bint is_hostile_set(uint64_t mask):
    return mask & (<uint64_t>1 << 7) != 0


cpdef inline bint is_type_set(uint64_t mask):
    return mask & (<uint64_t>1 << 8) != 0


cpdef inline bint is_mode_set(uint64_t mask):
    return mask & (<uint64_t>1 << 9) != 0


cpdef inline bint is_mode_time_set(uint64_t mask):
    return mask & (<uint64_t>1 << 10) != 0


cpdef inline bint is_hit_counter_set(uint64_t mask):
    return mask & (<uint64_t>1 << 11) != 0


cpdef inline bint is_last_hit_set(uint64_t mask):
    return mask & (<uint64_t>1 << 12) != 0


cpdef inline bint is_appearance_set(uint64_t mask):
    return mask & (<uint64_t>1 << 13) != 0


cpdef inline bint is_flags_set(uint64_t mask):
    return mask & (<uint64_t>1 << 14) != 0


cpdef inline bint is_roll_set(uint64_t mask):
    return mask & (<uint64_t>1 << 15) != 0


cpdef inline bint is_stun_set(uint64_t mask):
    return mask & (<uint64_t>1 << 16) != 0


cpdef inline bint is_slowed_set(uint64_t mask):
    return mask & (<uint64_t>1 << 17) != 0


cpdef inline bint is_make_blue_set(uint64_t mask):
    return mask & (<uint64_t>1 << 18) != 0


cpdef inline bint is_speed_up_set(uint64_t mask):
    return mask & (<uint64_t>1 << 19) != 0


cpdef inline bint is_show_patch_set(uint64_t mask):
    return mask & (<uint64_t>1 << 20) != 0


cpdef inline bint is_class_set(uint64_t mask):
    return mask & (<uint64_t>1 << 21) != 0


cpdef inline bint is_specialization_set(uint64_t mask):
    return mask & (<uint64_t>1 << 22) != 0


cpdef inline bint is_charged_mp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 23) != 0


cpdef inline bint is_ray_set(uint64_t mask):
    return mask & (<uint64_t>1 << 26) != 0


cpdef inline bint is_hp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 27) != 0


cpdef inline bint is_mp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 28) != 0


cpdef inline bint is_block_power_set(uint64_t mask):
    return mask & (<uint64_t>1 << 29) != 0


cpdef inline bint is_multiplier_set(uint64_t mask):
    return mask & (<uint64_t>1 << 30) != 0


cpdef inline bint is_level_set(uint64_t mask):
    return mask & (<uint64_t>1 << 33) != 0


cpdef inline bint is_xp_set(uint64_t mask):
    return mask & (<uint64_t>1 << 34) != 0


cpdef inline bint is_owner_set(uint64_t mask):
    return mask & (<uint64_t>1 << 35) != 0


cpdef inline bint is_power_base_set(uint64_t mask):
    return mask & (<uint64_t>1 << 37) != 0


cpdef inline bint is_start_chunk_set(uint64_t mask):
    return mask & (<uint64_t>1 << 39) != 0


cpdef inline bint is_spawn_set(uint64_t mask):
    return mask & (<uint64_t>1 << 40) != 0


cpdef inline bint is_consumable_set(uint64_t mask):
    return mask & (<uint64_t>1 << 43) != 0


cpdef inline bint is_equipment_set(uint64_t mask):
    return mask & (<uint64_t>1 << 44) != 0


cpdef inline bint is_name_set(uint64_t mask):
    return mask & (<uint64_t>1 << 45) != 0


cpdef inline bint is_skill_set(uint64_t mask):
    return mask & (<uint64_t>1 << 46) != 0


cpdef inline bint is_mana_cubes_set(uint64_t mask):
    return mask & (<uint64_t>1 << 47) != 0


cpdef uint64_t read_masked_data(WrapEntityData entity, ByteReader reader):
    cdef bytes temp
    cdef char * tempc
    cdef uint64_t mask = reader.read_uint64()
    if mask & (<uint64_t>1 << 0) != 0:
        reader.read_c(&entity.data[0].pos, sizeof(entity.data[0].pos))
    if mask & (<uint64_t>1 << 1) != 0:
        reader.read_c(&entity.data[0].body_roll, sizeof(entity.data[0].body_roll))
        reader.read_c(&entity.data[0].body_pitch, sizeof(entity.data[0].body_pitch))
        reader.read_c(&entity.data[0].body_yaw, sizeof(entity.data[0].body_yaw))
    if mask & (<uint64_t>1 << 2) != 0:
        reader.read_c(&entity.data[0].velocity, sizeof(entity.data[0].velocity))
    if mask & (<uint64_t>1 << 3) != 0:
        reader.read_c(&entity.data[0].accel, sizeof(entity.data[0].accel))
    if mask & (<uint64_t>1 << 4) != 0:
        reader.read_c(&entity.data[0].extra_vel, sizeof(entity.data[0].extra_vel))
    if mask & (<uint64_t>1 << 5) != 0:
        reader.read_c(&entity.data[0].look_pitch, sizeof(entity.data[0].look_pitch))
    if mask & (<uint64_t>1 << 6) != 0:
        reader.read_c(&entity.data[0].physics_flags, sizeof(entity.data[0].physics_flags))
    if mask & (<uint64_t>1 << 7) != 0:
        reader.read_c(&entity.data[0].hostile_type, sizeof(entity.data[0].hostile_type))
    if mask & (<uint64_t>1 << 8) != 0:
        reader.read_c(&entity.data[0].entity_type, sizeof(entity.data[0].entity_type))
    if mask & (<uint64_t>1 << 9) != 0:
        reader.read_c(&entity.data[0].current_mode, sizeof(entity.data[0].current_mode))
    if mask & (<uint64_t>1 << 10) != 0:
        reader.read_c(&entity.data[0].mode_start_time, sizeof(entity.data[0].mode_start_time))
    if mask & (<uint64_t>1 << 11) != 0:
        reader.read_c(&entity.data[0].hit_counter, sizeof(entity.data[0].hit_counter))
    if mask & (<uint64_t>1 << 12) != 0:
        reader.read_c(&entity.data[0].last_hit_time, sizeof(entity.data[0].last_hit_time))
    if mask & (<uint64_t>1 << 13) != 0:
        reader.read_c(&entity.data[0].appearance, sizeof(entity.data[0].appearance))
    if mask & (<uint64_t>1 << 14) != 0:
        reader.read_c(&entity.data[0].flags, sizeof(entity.data[0].flags))
    if mask & (<uint64_t>1 << 15) != 0:
        reader.read_c(&entity.data[0].roll_time, sizeof(entity.data[0].roll_time))
    if mask & (<uint64_t>1 << 16) != 0:
        reader.read_c(&entity.data[0].stun_time, sizeof(entity.data[0].stun_time))
    if mask & (<uint64_t>1 << 17) != 0:
        reader.read_c(&entity.data[0].slowed_time, sizeof(entity.data[0].slowed_time))
    if mask & (<uint64_t>1 << 18) != 0:
        reader.read_c(&entity.data[0].make_blue_time, sizeof(entity.data[0].make_blue_time))
    if mask & (<uint64_t>1 << 19) != 0:
        reader.read_c(&entity.data[0].speed_up_time, sizeof(entity.data[0].speed_up_time))
    if mask & (<uint64_t>1 << 20) != 0:
        reader.read_c(&entity.data[0].show_patch_time, sizeof(entity.data[0].show_patch_time))
    if mask & (<uint64_t>1 << 21) != 0:
        reader.read_c(&entity.data[0].class_type, sizeof(entity.data[0].class_type))
    if mask & (<uint64_t>1 << 22) != 0:
        reader.read_c(&entity.data[0].specialization, sizeof(entity.data[0].specialization))
    if mask & (<uint64_t>1 << 23) != 0:
        reader.read_c(&entity.data[0].charged_mp, sizeof(entity.data[0].charged_mp))
    if mask & (<uint64_t>1 << 24) != 0:
        reader.read_c(&entity.data[0].not_used_1, sizeof(entity.data[0].not_used_1))
        reader.read_c(&entity.data[0].not_used_2, sizeof(entity.data[0].not_used_2))
        reader.read_c(&entity.data[0].not_used_3, sizeof(entity.data[0].not_used_3))
    if mask & (<uint64_t>1 << 25) != 0:
        reader.read_c(&entity.data[0].not_used_4, sizeof(entity.data[0].not_used_4))
        reader.read_c(&entity.data[0].not_used_5, sizeof(entity.data[0].not_used_5))
        reader.read_c(&entity.data[0].not_used_6, sizeof(entity.data[0].not_used_6))
    if mask & (<uint64_t>1 << 26) != 0:
        reader.read_c(&entity.data[0].ray_hit, sizeof(entity.data[0].ray_hit))
    if mask & (<uint64_t>1 << 27) != 0:
        reader.read_c(&entity.data[0].hp, sizeof(entity.data[0].hp))
    if mask & (<uint64_t>1 << 28) != 0:
        reader.read_c(&entity.data[0].mp, sizeof(entity.data[0].mp))
    if mask & (<uint64_t>1 << 29) != 0:
        reader.read_c(&entity.data[0].block_power, sizeof(entity.data[0].block_power))
    if mask & (<uint64_t>1 << 30) != 0:
        reader.read_c(&entity.data[0].max_hp_multiplier, sizeof(entity.data[0].max_hp_multiplier))
        reader.read_c(&entity.data[0].shoot_speed, sizeof(entity.data[0].shoot_speed))
        reader.read_c(&entity.data[0].damage_multiplier, sizeof(entity.data[0].damage_multiplier))
        reader.read_c(&entity.data[0].armor_multiplier, sizeof(entity.data[0].armor_multiplier))
        reader.read_c(&entity.data[0].resi_multiplier, sizeof(entity.data[0].resi_multiplier))
    if mask & (<uint64_t>1 << 31) != 0:
        reader.read_c(&entity.data[0].not_used7, sizeof(entity.data[0].not_used7))
    if mask & (<uint64_t>1 << 32) != 0:
        reader.read_c(&entity.data[0].not_used8, sizeof(entity.data[0].not_used8))
    if mask & (<uint64_t>1 << 33) != 0:
        reader.read_c(&entity.data[0].level, sizeof(entity.data[0].level))
    if mask & (<uint64_t>1 << 34) != 0:
        reader.read_c(&entity.data[0].current_xp, sizeof(entity.data[0].current_xp))
    if mask & (<uint64_t>1 << 35) != 0:
        reader.read_c(&entity.data[0].parent_owner, sizeof(entity.data[0].parent_owner))
    if mask & (<uint64_t>1 << 36) != 0:
        reader.read_c(&entity.data[0].unknown_or_not_used1, sizeof(entity.data[0].unknown_or_not_used1))
        reader.read_c(&entity.data[0].unknown_or_not_used2, sizeof(entity.data[0].unknown_or_not_used2))
    if mask & (<uint64_t>1 << 37) != 0:
        reader.read_c(&entity.data[0].power_base, sizeof(entity.data[0].power_base))
    if mask & (<uint64_t>1 << 38) != 0:
        reader.read_c(&entity.data[0].unknown_or_not_used4, sizeof(entity.data[0].unknown_or_not_used4))
    if mask & (<uint64_t>1 << 39) != 0:
        reader.read_c(&entity.data[0].start_chunk, sizeof(entity.data[0].start_chunk))
    if mask & (<uint64_t>1 << 40) != 0:
        reader.read_c(&entity.data[0].spawn_pos, sizeof(entity.data[0].spawn_pos))
    if mask & (<uint64_t>1 << 41) != 0:
        reader.read_c(&entity.data[0].not_used20, sizeof(entity.data[0].not_used20))
    if mask & (<uint64_t>1 << 42) != 0:
        reader.read_c(&entity.data[0].not_used19, sizeof(entity.data[0].not_used19))
    if mask & (<uint64_t>1 << 43) != 0:
        reader.read_c(&entity.data[0].consumable, sizeof(entity.data[0].consumable))
    if mask & (<uint64_t>1 << 44) != 0:
        reader.read_c(&entity.data[0].equipment, sizeof(entity.data[0].equipment))
    if mask & (<uint64_t>1 << 45) != 0:
        reader.read_c(&entity.data[0].name, sizeof(entity.data[0].name))
    if mask & (<uint64_t>1 << 46) != 0:
        reader.read_c(&entity.data[0].skills, sizeof(entity.data[0].skills))
    if mask & (<uint64_t>1 << 47) != 0:
        reader.read_c(&entity.data[0].mana_cubes, sizeof(entity.data[0].mana_cubes))

    return mask


cpdef unsigned int get_masked_size(uint64_t mask):
    cdef unsigned int size = 0
    if mask & (<uint64_t>1 << 0) != 0:
        size += 24
    if mask & (<uint64_t>1 << 1) != 0:
        size += 12
    if mask & (<uint64_t>1 << 2) != 0:
        size += 12
    if mask & (<uint64_t>1 << 3) != 0:
        size += 12
    if mask & (<uint64_t>1 << 4) != 0:
        size += 12
    if mask & (<uint64_t>1 << 5) != 0:
        size += 4
    if mask & (<uint64_t>1 << 6) != 0:
        size += 4
    if mask & (<uint64_t>1 << 7) != 0:
        size += 1
    if mask & (<uint64_t>1 << 8) != 0:
        size += 4
    if mask & (<uint64_t>1 << 9) != 0:
        size += 1
    if mask & (<uint64_t>1 << 10) != 0:
        size += 4
    if mask & (<uint64_t>1 << 11) != 0:
        size += 4
    if mask & (<uint64_t>1 << 12) != 0:
        size += 4
    if mask & (<uint64_t>1 << 13) != 0:
        size += 172
    if mask & (<uint64_t>1 << 14) != 0:
        size += 2
    if mask & (<uint64_t>1 << 15) != 0:
        size += 4
    if mask & (<uint64_t>1 << 16) != 0:
        size += 4
    if mask & (<uint64_t>1 << 17) != 0:
        size += 4
    if mask & (<uint64_t>1 << 18) != 0:
        size += 4
    if mask & (<uint64_t>1 << 19) != 0:
        size += 4
    if mask & (<uint64_t>1 << 20) != 0:
        size += 4
    if mask & (<uint64_t>1 << 21) != 0:
        size += 1
    if mask & (<uint64_t>1 << 22) != 0:
        size += 1
    if mask & (<uint64_t>1 << 23) != 0:
        size += 4
    if mask & (<uint64_t>1 << 24) != 0:
        size += 12
    if mask & (<uint64_t>1 << 25) != 0:
        size += 12
    if mask & (<uint64_t>1 << 26) != 0:
        size += 12
    if mask & (<uint64_t>1 << 27) != 0:
        size += 4
    if mask & (<uint64_t>1 << 28) != 0:
        size += 4
    if mask & (<uint64_t>1 << 29) != 0:
        size += 4
    if mask & (<uint64_t>1 << 30) != 0:
        size += 20
    if mask & (<uint64_t>1 << 31) != 0:
        size += 1
    if mask & (<uint64_t>1 << 32) != 0:
        size += 1
    if mask & (<uint64_t>1 << 33) != 0:
        size += 4
    if mask & (<uint64_t>1 << 34) != 0:
        size += 4
    if mask & (<uint64_t>1 << 35) != 0:
        size += 8
    if mask & (<uint64_t>1 << 36) != 0:
        size += 8
    if mask & (<uint64_t>1 << 37) != 0:
        size += 1
    if mask & (<uint64_t>1 << 38) != 0:
        size += 4
    if mask & (<uint64_t>1 << 39) != 0:
        size += 12
    if mask & (<uint64_t>1 << 40) != 0:
        size += 24
    if mask & (<uint64_t>1 << 41) != 0:
        size += 12
    if mask & (<uint64_t>1 << 42) != 0:
        size += 1
    if mask & (<uint64_t>1 << 43) != 0:
        size += 280
    if mask & (<uint64_t>1 << 44) != 0:
        size += 3640
    if mask & (<uint64_t>1 << 45) != 0:
        size += 16
    if mask & (<uint64_t>1 << 46) != 0:
        size += 44
    if mask & (<uint64_t>1 << 47) != 0:
        size += 4
    return size


cpdef write_masked_data(WrapEntityData entity, ByteWriter writer, uint64_t mask):
    writer.write_uint64(mask)
    cdef bytes view
    if mask & (<uint64_t>1 << 0) != 0:
        writer.write_c(&entity.data[0].pos, sizeof(entity.data[0].pos))
    if mask & (<uint64_t>1 << 1) != 0:
        writer.write_c(&entity.data[0].body_roll, sizeof(entity.data[0].body_roll))
        writer.write_c(&entity.data[0].body_pitch, sizeof(entity.data[0].body_pitch))
        writer.write_c(&entity.data[0].body_yaw, sizeof(entity.data[0].body_yaw))
    if mask & (<uint64_t>1 << 2) != 0:
        writer.write_c(&entity.data[0].velocity, sizeof(entity.data[0].velocity))
    if mask & (<uint64_t>1 << 3) != 0:
        writer.write_c(&entity.data[0].accel, sizeof(entity.data[0].accel))
    if mask & (<uint64_t>1 << 4) != 0:
        writer.write_c(&entity.data[0].extra_vel, sizeof(entity.data[0].extra_vel))
    if mask & (<uint64_t>1 << 5) != 0:
        writer.write_c(&entity.data[0].look_pitch, sizeof(entity.data[0].look_pitch))
    if mask & (<uint64_t>1 << 6) != 0:
        writer.write_c(&entity.data[0].physics_flags, sizeof(entity.data[0].physics_flags))
    if mask & (<uint64_t>1 << 7) != 0:
        writer.write_c(&entity.data[0].hostile_type, sizeof(entity.data[0].hostile_type))
    if mask & (<uint64_t>1 << 8) != 0:
        writer.write_c(&entity.data[0].entity_type, sizeof(entity.data[0].entity_type))
    if mask & (<uint64_t>1 << 9) != 0:
        writer.write_c(&entity.data[0].current_mode, sizeof(entity.data[0].current_mode))
    if mask & (<uint64_t>1 << 10) != 0:
        writer.write_c(&entity.data[0].mode_start_time, sizeof(entity.data[0].mode_start_time))
    if mask & (<uint64_t>1 << 11) != 0:
        writer.write_c(&entity.data[0].hit_counter, sizeof(entity.data[0].hit_counter))
    if mask & (<uint64_t>1 << 12) != 0:
        writer.write_c(&entity.data[0].last_hit_time, sizeof(entity.data[0].last_hit_time))
    if mask & (<uint64_t>1 << 13) != 0:
        writer.write_c(&entity.data[0].appearance, sizeof(entity.data[0].appearance))
    if mask & (<uint64_t>1 << 14) != 0:
        writer.write_c(&entity.data[0].flags, sizeof(entity.data[0].flags))
    if mask & (<uint64_t>1 << 15) != 0:
        writer.write_c(&entity.data[0].roll_time, sizeof(entity.data[0].roll_time))
    if mask & (<uint64_t>1 << 16) != 0:
        writer.write_c(&entity.data[0].stun_time, sizeof(entity.data[0].stun_time))
    if mask & (<uint64_t>1 << 17) != 0:
        writer.write_c(&entity.data[0].slowed_time, sizeof(entity.data[0].slowed_time))
    if mask & (<uint64_t>1 << 18) != 0:
        writer.write_c(&entity.data[0].make_blue_time, sizeof(entity.data[0].make_blue_time))
    if mask & (<uint64_t>1 << 19) != 0:
        writer.write_c(&entity.data[0].speed_up_time, sizeof(entity.data[0].speed_up_time))
    if mask & (<uint64_t>1 << 20) != 0:
        writer.write_c(&entity.data[0].show_patch_time, sizeof(entity.data[0].show_patch_time))
    if mask & (<uint64_t>1 << 21) != 0:
        writer.write_c(&entity.data[0].class_type, sizeof(entity.data[0].class_type))
    if mask & (<uint64_t>1 << 22) != 0:
        writer.write_c(&entity.data[0].specialization, sizeof(entity.data[0].specialization))
    if mask & (<uint64_t>1 << 23) != 0:
        writer.write_c(&entity.data[0].charged_mp, sizeof(entity.data[0].charged_mp))
    if mask & (<uint64_t>1 << 24) != 0:
        writer.write_c(&entity.data[0].not_used_1, sizeof(entity.data[0].not_used_1))
        writer.write_c(&entity.data[0].not_used_2, sizeof(entity.data[0].not_used_2))
        writer.write_c(&entity.data[0].not_used_3, sizeof(entity.data[0].not_used_3))
    if mask & (<uint64_t>1 << 25) != 0:
        writer.write_c(&entity.data[0].not_used_4, sizeof(entity.data[0].not_used_4))
        writer.write_c(&entity.data[0].not_used_5, sizeof(entity.data[0].not_used_5))
        writer.write_c(&entity.data[0].not_used_6, sizeof(entity.data[0].not_used_6))
    if mask & (<uint64_t>1 << 26) != 0:
        writer.write_c(&entity.data[0].ray_hit, sizeof(entity.data[0].ray_hit))
    if mask & (<uint64_t>1 << 27) != 0:
        writer.write_c(&entity.data[0].hp, sizeof(entity.data[0].hp))
    if mask & (<uint64_t>1 << 28) != 0:
        writer.write_c(&entity.data[0].mp, sizeof(entity.data[0].mp))
    if mask & (<uint64_t>1 << 29) != 0:
        writer.write_c(&entity.data[0].block_power, sizeof(entity.data[0].block_power))
    if mask & (<uint64_t>1 << 30) != 0:
        writer.write_c(&entity.data[0].max_hp_multiplier, sizeof(entity.data[0].max_hp_multiplier))
        writer.write_c(&entity.data[0].shoot_speed, sizeof(entity.data[0].shoot_speed))
        writer.write_c(&entity.data[0].damage_multiplier, sizeof(entity.data[0].damage_multiplier))
        writer.write_c(&entity.data[0].armor_multiplier, sizeof(entity.data[0].armor_multiplier))
        writer.write_c(&entity.data[0].resi_multiplier, sizeof(entity.data[0].resi_multiplier))
    if mask & (<uint64_t>1 << 31) != 0:
        writer.write_c(&entity.data[0].not_used7, sizeof(entity.data[0].not_used7))
    if mask & (<uint64_t>1 << 32) != 0:
        writer.write_c(&entity.data[0].not_used8, sizeof(entity.data[0].not_used8))
    if mask & (<uint64_t>1 << 33) != 0:
        writer.write_c(&entity.data[0].level, sizeof(entity.data[0].level))
    if mask & (<uint64_t>1 << 34) != 0:
        writer.write_c(&entity.data[0].current_xp, sizeof(entity.data[0].current_xp))
    if mask & (<uint64_t>1 << 35) != 0:
        writer.write_c(&entity.data[0].parent_owner, sizeof(entity.data[0].parent_owner))
    if mask & (<uint64_t>1 << 36) != 0:
        writer.write_c(&entity.data[0].unknown_or_not_used1, sizeof(entity.data[0].unknown_or_not_used1))
        writer.write_c(&entity.data[0].unknown_or_not_used2, sizeof(entity.data[0].unknown_or_not_used2))
    if mask & (<uint64_t>1 << 37) != 0:
        writer.write_c(&entity.data[0].power_base, sizeof(entity.data[0].power_base))
    if mask & (<uint64_t>1 << 38) != 0:
        writer.write_c(&entity.data[0].unknown_or_not_used4, sizeof(entity.data[0].unknown_or_not_used4))
    if mask & (<uint64_t>1 << 39) != 0:
        writer.write_c(&entity.data[0].start_chunk, sizeof(entity.data[0].start_chunk))
    if mask & (<uint64_t>1 << 40) != 0:
        writer.write_c(&entity.data[0].spawn_pos, sizeof(entity.data[0].spawn_pos))
    if mask & (<uint64_t>1 << 41) != 0:
        writer.write_c(&entity.data[0].not_used20, sizeof(entity.data[0].not_used20))
    if mask & (<uint64_t>1 << 42) != 0:
        writer.write_c(&entity.data[0].not_used19, sizeof(entity.data[0].not_used19))
    if mask & (<uint64_t>1 << 43) != 0:
        writer.write_c(&entity.data[0].consumable, sizeof(entity.data[0].consumable))
    if mask & (<uint64_t>1 << 44) != 0:
        writer.write_c(&entity.data[0].equipment, sizeof(entity.data[0].equipment))
    if mask & (<uint64_t>1 << 45) != 0:
        writer.write_c(&entity.data[0].name, sizeof(entity.data[0].name))
    if mask & (<uint64_t>1 << 46) != 0:
        writer.write_c(&entity.data[0].skills, sizeof(entity.data[0].skills))
    if mask & (<uint64_t>1 << 47) != 0:
        writer.write_c(&entity.data[0].mana_cubes, sizeof(entity.data[0].mana_cubes))
